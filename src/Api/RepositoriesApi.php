<?php
/**
 * RepositoriesApi
 * PHP version 5
 *
 * @category Class
 * @package  Gitee
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Gitee Open API
 *
 * Gitee SDK for PHP
 *
 * OpenAPI spec version: 5.4.85
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.42
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Gitee\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Gitee\ApiException;
use Gitee\Configuration;
use Gitee\HeaderSelector;
use Gitee\ObjectSerializer;

/**
 * RepositoriesApi Class Doc Comment
 *
 * @category Class
 * @package  Gitee
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class RepositoriesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation deleteV5ReposOwnerRepo
     *
     * 删除一个仓库
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteV5ReposOwnerRepo($owner, $repo, $accessToken = null)
    {
        $this->deleteV5ReposOwnerRepoWithHttpInfo($owner, $repo, $accessToken);
    }

    /**
     * Operation deleteV5ReposOwnerRepoWithHttpInfo
     *
     * 删除一个仓库
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteV5ReposOwnerRepoWithHttpInfo($owner, $repo, $accessToken = null)
    {
        $returnType = '';
        $request = $this->deleteV5ReposOwnerRepoRequest($owner, $repo, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteV5ReposOwnerRepoAsync
     *
     * 删除一个仓库
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteV5ReposOwnerRepoAsync($owner, $repo, $accessToken = null)
    {
        return $this->deleteV5ReposOwnerRepoAsyncWithHttpInfo($owner, $repo, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteV5ReposOwnerRepoAsyncWithHttpInfo
     *
     * 删除一个仓库
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteV5ReposOwnerRepoAsyncWithHttpInfo($owner, $repo, $accessToken = null)
    {
        $returnType = '';
        $request = $this->deleteV5ReposOwnerRepoRequest($owner, $repo, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteV5ReposOwnerRepo'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteV5ReposOwnerRepoRequest($owner, $repo, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling deleteV5ReposOwnerRepo'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling deleteV5ReposOwnerRepo'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteV5ReposOwnerRepoBaiduStatisticKey
     *
     * 删除仓库的百度统计 key
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteV5ReposOwnerRepoBaiduStatisticKey($owner, $repo, $accessToken = null)
    {
        $this->deleteV5ReposOwnerRepoBaiduStatisticKeyWithHttpInfo($owner, $repo, $accessToken);
    }

    /**
     * Operation deleteV5ReposOwnerRepoBaiduStatisticKeyWithHttpInfo
     *
     * 删除仓库的百度统计 key
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteV5ReposOwnerRepoBaiduStatisticKeyWithHttpInfo($owner, $repo, $accessToken = null)
    {
        $returnType = '';
        $request = $this->deleteV5ReposOwnerRepoBaiduStatisticKeyRequest($owner, $repo, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteV5ReposOwnerRepoBaiduStatisticKeyAsync
     *
     * 删除仓库的百度统计 key
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteV5ReposOwnerRepoBaiduStatisticKeyAsync($owner, $repo, $accessToken = null)
    {
        return $this->deleteV5ReposOwnerRepoBaiduStatisticKeyAsyncWithHttpInfo($owner, $repo, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteV5ReposOwnerRepoBaiduStatisticKeyAsyncWithHttpInfo
     *
     * 删除仓库的百度统计 key
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteV5ReposOwnerRepoBaiduStatisticKeyAsyncWithHttpInfo($owner, $repo, $accessToken = null)
    {
        $returnType = '';
        $request = $this->deleteV5ReposOwnerRepoBaiduStatisticKeyRequest($owner, $repo, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteV5ReposOwnerRepoBaiduStatisticKey'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteV5ReposOwnerRepoBaiduStatisticKeyRequest($owner, $repo, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling deleteV5ReposOwnerRepoBaiduStatisticKey'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling deleteV5ReposOwnerRepoBaiduStatisticKey'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/baidu_statistic_key';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteV5ReposOwnerRepoBranchesBranchProtection
     *
     * 取消保护分支的设置
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $branch 分支名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteV5ReposOwnerRepoBranchesBranchProtection($owner, $repo, $branch, $accessToken = null)
    {
        $this->deleteV5ReposOwnerRepoBranchesBranchProtectionWithHttpInfo($owner, $repo, $branch, $accessToken);
    }

    /**
     * Operation deleteV5ReposOwnerRepoBranchesBranchProtectionWithHttpInfo
     *
     * 取消保护分支的设置
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $branch 分支名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteV5ReposOwnerRepoBranchesBranchProtectionWithHttpInfo($owner, $repo, $branch, $accessToken = null)
    {
        $returnType = '';
        $request = $this->deleteV5ReposOwnerRepoBranchesBranchProtectionRequest($owner, $repo, $branch, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteV5ReposOwnerRepoBranchesBranchProtectionAsync
     *
     * 取消保护分支的设置
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $branch 分支名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteV5ReposOwnerRepoBranchesBranchProtectionAsync($owner, $repo, $branch, $accessToken = null)
    {
        return $this->deleteV5ReposOwnerRepoBranchesBranchProtectionAsyncWithHttpInfo($owner, $repo, $branch, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteV5ReposOwnerRepoBranchesBranchProtectionAsyncWithHttpInfo
     *
     * 取消保护分支的设置
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $branch 分支名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteV5ReposOwnerRepoBranchesBranchProtectionAsyncWithHttpInfo($owner, $repo, $branch, $accessToken = null)
    {
        $returnType = '';
        $request = $this->deleteV5ReposOwnerRepoBranchesBranchProtectionRequest($owner, $repo, $branch, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteV5ReposOwnerRepoBranchesBranchProtection'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $branch 分支名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteV5ReposOwnerRepoBranchesBranchProtectionRequest($owner, $repo, $branch, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling deleteV5ReposOwnerRepoBranchesBranchProtection'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling deleteV5ReposOwnerRepoBranchesBranchProtection'
            );
        }
        // verify the required parameter 'branch' is set
        if ($branch === null || (is_array($branch) && count($branch) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $branch when calling deleteV5ReposOwnerRepoBranchesBranchProtection'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/branches/{branch}/protection';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($branch !== null) {
            $resourcePath = str_replace(
                '{' . 'branch' . '}',
                ObjectSerializer::toPathValue($branch),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteV5ReposOwnerRepoBranchesWildcardSetting
     *
     * 删除保护分支规则
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $wildcard 分支/通配符 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\ProtectionRule
     */
    public function deleteV5ReposOwnerRepoBranchesWildcardSetting($owner, $repo, $wildcard, $accessToken = null)
    {
        list($response) = $this->deleteV5ReposOwnerRepoBranchesWildcardSettingWithHttpInfo($owner, $repo, $wildcard, $accessToken);
        return $response;
    }

    /**
     * Operation deleteV5ReposOwnerRepoBranchesWildcardSettingWithHttpInfo
     *
     * 删除保护分支规则
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $wildcard 分支/通配符 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\ProtectionRule, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteV5ReposOwnerRepoBranchesWildcardSettingWithHttpInfo($owner, $repo, $wildcard, $accessToken = null)
    {
        $returnType = '\Gitee\Model\ProtectionRule';
        $request = $this->deleteV5ReposOwnerRepoBranchesWildcardSettingRequest($owner, $repo, $wildcard, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\ProtectionRule',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteV5ReposOwnerRepoBranchesWildcardSettingAsync
     *
     * 删除保护分支规则
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $wildcard 分支/通配符 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteV5ReposOwnerRepoBranchesWildcardSettingAsync($owner, $repo, $wildcard, $accessToken = null)
    {
        return $this->deleteV5ReposOwnerRepoBranchesWildcardSettingAsyncWithHttpInfo($owner, $repo, $wildcard, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteV5ReposOwnerRepoBranchesWildcardSettingAsyncWithHttpInfo
     *
     * 删除保护分支规则
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $wildcard 分支/通配符 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteV5ReposOwnerRepoBranchesWildcardSettingAsyncWithHttpInfo($owner, $repo, $wildcard, $accessToken = null)
    {
        $returnType = '\Gitee\Model\ProtectionRule';
        $request = $this->deleteV5ReposOwnerRepoBranchesWildcardSettingRequest($owner, $repo, $wildcard, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteV5ReposOwnerRepoBranchesWildcardSetting'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $wildcard 分支/通配符 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteV5ReposOwnerRepoBranchesWildcardSettingRequest($owner, $repo, $wildcard, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling deleteV5ReposOwnerRepoBranchesWildcardSetting'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling deleteV5ReposOwnerRepoBranchesWildcardSetting'
            );
        }
        // verify the required parameter 'wildcard' is set
        if ($wildcard === null || (is_array($wildcard) && count($wildcard) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wildcard when calling deleteV5ReposOwnerRepoBranchesWildcardSetting'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/branches/{wildcard}/setting';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($wildcard !== null) {
            $resourcePath = str_replace(
                '{' . 'wildcard' . '}',
                ObjectSerializer::toPathValue($wildcard),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteV5ReposOwnerRepoCollaboratorsUsername
     *
     * 移除仓库成员
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $username 用户名(username/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteV5ReposOwnerRepoCollaboratorsUsername($owner, $repo, $username, $accessToken = null)
    {
        $this->deleteV5ReposOwnerRepoCollaboratorsUsernameWithHttpInfo($owner, $repo, $username, $accessToken);
    }

    /**
     * Operation deleteV5ReposOwnerRepoCollaboratorsUsernameWithHttpInfo
     *
     * 移除仓库成员
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $username 用户名(username/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteV5ReposOwnerRepoCollaboratorsUsernameWithHttpInfo($owner, $repo, $username, $accessToken = null)
    {
        $returnType = '';
        $request = $this->deleteV5ReposOwnerRepoCollaboratorsUsernameRequest($owner, $repo, $username, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteV5ReposOwnerRepoCollaboratorsUsernameAsync
     *
     * 移除仓库成员
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $username 用户名(username/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteV5ReposOwnerRepoCollaboratorsUsernameAsync($owner, $repo, $username, $accessToken = null)
    {
        return $this->deleteV5ReposOwnerRepoCollaboratorsUsernameAsyncWithHttpInfo($owner, $repo, $username, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteV5ReposOwnerRepoCollaboratorsUsernameAsyncWithHttpInfo
     *
     * 移除仓库成员
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $username 用户名(username/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteV5ReposOwnerRepoCollaboratorsUsernameAsyncWithHttpInfo($owner, $repo, $username, $accessToken = null)
    {
        $returnType = '';
        $request = $this->deleteV5ReposOwnerRepoCollaboratorsUsernameRequest($owner, $repo, $username, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteV5ReposOwnerRepoCollaboratorsUsername'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $username 用户名(username/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteV5ReposOwnerRepoCollaboratorsUsernameRequest($owner, $repo, $username, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling deleteV5ReposOwnerRepoCollaboratorsUsername'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling deleteV5ReposOwnerRepoCollaboratorsUsername'
            );
        }
        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling deleteV5ReposOwnerRepoCollaboratorsUsername'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/collaborators/{username}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteV5ReposOwnerRepoCommentsId
     *
     * 删除Commit评论
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 评论的ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteV5ReposOwnerRepoCommentsId($owner, $repo, $id, $accessToken = null)
    {
        $this->deleteV5ReposOwnerRepoCommentsIdWithHttpInfo($owner, $repo, $id, $accessToken);
    }

    /**
     * Operation deleteV5ReposOwnerRepoCommentsIdWithHttpInfo
     *
     * 删除Commit评论
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 评论的ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteV5ReposOwnerRepoCommentsIdWithHttpInfo($owner, $repo, $id, $accessToken = null)
    {
        $returnType = '';
        $request = $this->deleteV5ReposOwnerRepoCommentsIdRequest($owner, $repo, $id, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteV5ReposOwnerRepoCommentsIdAsync
     *
     * 删除Commit评论
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 评论的ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteV5ReposOwnerRepoCommentsIdAsync($owner, $repo, $id, $accessToken = null)
    {
        return $this->deleteV5ReposOwnerRepoCommentsIdAsyncWithHttpInfo($owner, $repo, $id, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteV5ReposOwnerRepoCommentsIdAsyncWithHttpInfo
     *
     * 删除Commit评论
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 评论的ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteV5ReposOwnerRepoCommentsIdAsyncWithHttpInfo($owner, $repo, $id, $accessToken = null)
    {
        $returnType = '';
        $request = $this->deleteV5ReposOwnerRepoCommentsIdRequest($owner, $repo, $id, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteV5ReposOwnerRepoCommentsId'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 评论的ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteV5ReposOwnerRepoCommentsIdRequest($owner, $repo, $id, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling deleteV5ReposOwnerRepoCommentsId'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling deleteV5ReposOwnerRepoCommentsId'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteV5ReposOwnerRepoCommentsId'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/comments/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteV5ReposOwnerRepoContentsPath
     *
     * 删除文件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径 (required)
     * @param  string $sha 文件的 Blob SHA，可通过 [获取仓库具体路径下的内容] API 获取 (required)
     * @param  string $message 提交信息 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $branch 分支名称。默认为仓库对默认分支 (optional)
     * @param  string $committerName Committer的名字，默认为当前用户的名字 (optional)
     * @param  string $committerEmail Committer的邮箱，默认为当前用户的邮箱 (optional)
     * @param  string $authorName Author的名字，默认为当前用户的名字 (optional)
     * @param  string $authorEmail Author的邮箱，默认为当前用户的邮箱 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\CommitContent
     */
    public function deleteV5ReposOwnerRepoContentsPath($owner, $repo, $path, $sha, $message, $accessToken = null, $branch = null, $committerName = null, $committerEmail = null, $authorName = null, $authorEmail = null)
    {
        list($response) = $this->deleteV5ReposOwnerRepoContentsPathWithHttpInfo($owner, $repo, $path, $sha, $message, $accessToken, $branch, $committerName, $committerEmail, $authorName, $authorEmail);
        return $response;
    }

    /**
     * Operation deleteV5ReposOwnerRepoContentsPathWithHttpInfo
     *
     * 删除文件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径 (required)
     * @param  string $sha 文件的 Blob SHA，可通过 [获取仓库具体路径下的内容] API 获取 (required)
     * @param  string $message 提交信息 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $branch 分支名称。默认为仓库对默认分支 (optional)
     * @param  string $committerName Committer的名字，默认为当前用户的名字 (optional)
     * @param  string $committerEmail Committer的邮箱，默认为当前用户的邮箱 (optional)
     * @param  string $authorName Author的名字，默认为当前用户的名字 (optional)
     * @param  string $authorEmail Author的邮箱，默认为当前用户的邮箱 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\CommitContent, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteV5ReposOwnerRepoContentsPathWithHttpInfo($owner, $repo, $path, $sha, $message, $accessToken = null, $branch = null, $committerName = null, $committerEmail = null, $authorName = null, $authorEmail = null)
    {
        $returnType = '\Gitee\Model\CommitContent';
        $request = $this->deleteV5ReposOwnerRepoContentsPathRequest($owner, $repo, $path, $sha, $message, $accessToken, $branch, $committerName, $committerEmail, $authorName, $authorEmail);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\CommitContent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteV5ReposOwnerRepoContentsPathAsync
     *
     * 删除文件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径 (required)
     * @param  string $sha 文件的 Blob SHA，可通过 [获取仓库具体路径下的内容] API 获取 (required)
     * @param  string $message 提交信息 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $branch 分支名称。默认为仓库对默认分支 (optional)
     * @param  string $committerName Committer的名字，默认为当前用户的名字 (optional)
     * @param  string $committerEmail Committer的邮箱，默认为当前用户的邮箱 (optional)
     * @param  string $authorName Author的名字，默认为当前用户的名字 (optional)
     * @param  string $authorEmail Author的邮箱，默认为当前用户的邮箱 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteV5ReposOwnerRepoContentsPathAsync($owner, $repo, $path, $sha, $message, $accessToken = null, $branch = null, $committerName = null, $committerEmail = null, $authorName = null, $authorEmail = null)
    {
        return $this->deleteV5ReposOwnerRepoContentsPathAsyncWithHttpInfo($owner, $repo, $path, $sha, $message, $accessToken, $branch, $committerName, $committerEmail, $authorName, $authorEmail)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteV5ReposOwnerRepoContentsPathAsyncWithHttpInfo
     *
     * 删除文件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径 (required)
     * @param  string $sha 文件的 Blob SHA，可通过 [获取仓库具体路径下的内容] API 获取 (required)
     * @param  string $message 提交信息 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $branch 分支名称。默认为仓库对默认分支 (optional)
     * @param  string $committerName Committer的名字，默认为当前用户的名字 (optional)
     * @param  string $committerEmail Committer的邮箱，默认为当前用户的邮箱 (optional)
     * @param  string $authorName Author的名字，默认为当前用户的名字 (optional)
     * @param  string $authorEmail Author的邮箱，默认为当前用户的邮箱 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteV5ReposOwnerRepoContentsPathAsyncWithHttpInfo($owner, $repo, $path, $sha, $message, $accessToken = null, $branch = null, $committerName = null, $committerEmail = null, $authorName = null, $authorEmail = null)
    {
        $returnType = '\Gitee\Model\CommitContent';
        $request = $this->deleteV5ReposOwnerRepoContentsPathRequest($owner, $repo, $path, $sha, $message, $accessToken, $branch, $committerName, $committerEmail, $authorName, $authorEmail);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteV5ReposOwnerRepoContentsPath'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径 (required)
     * @param  string $sha 文件的 Blob SHA，可通过 [获取仓库具体路径下的内容] API 获取 (required)
     * @param  string $message 提交信息 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $branch 分支名称。默认为仓库对默认分支 (optional)
     * @param  string $committerName Committer的名字，默认为当前用户的名字 (optional)
     * @param  string $committerEmail Committer的邮箱，默认为当前用户的邮箱 (optional)
     * @param  string $authorName Author的名字，默认为当前用户的名字 (optional)
     * @param  string $authorEmail Author的邮箱，默认为当前用户的邮箱 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteV5ReposOwnerRepoContentsPathRequest($owner, $repo, $path, $sha, $message, $accessToken = null, $branch = null, $committerName = null, $committerEmail = null, $authorName = null, $authorEmail = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling deleteV5ReposOwnerRepoContentsPath'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling deleteV5ReposOwnerRepoContentsPath'
            );
        }
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling deleteV5ReposOwnerRepoContentsPath'
            );
        }
        // verify the required parameter 'sha' is set
        if ($sha === null || (is_array($sha) && count($sha) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sha when calling deleteV5ReposOwnerRepoContentsPath'
            );
        }
        // verify the required parameter 'message' is set
        if ($message === null || (is_array($message) && count($message) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message when calling deleteV5ReposOwnerRepoContentsPath'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/contents/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }
        // query params
        if ($sha !== null) {
            $queryParams['sha'] = ObjectSerializer::toQueryValue($sha);
        }
        // query params
        if ($message !== null) {
            $queryParams['message'] = ObjectSerializer::toQueryValue($message);
        }
        // query params
        if ($branch !== null) {
            $queryParams['branch'] = ObjectSerializer::toQueryValue($branch);
        }
        // query params
        if ($committerName !== null) {
            $queryParams['committer[name]'] = ObjectSerializer::toQueryValue($committerName);
        }
        // query params
        if ($committerEmail !== null) {
            $queryParams['committer[email]'] = ObjectSerializer::toQueryValue($committerEmail);
        }
        // query params
        if ($authorName !== null) {
            $queryParams['author[name]'] = ObjectSerializer::toQueryValue($authorName);
        }
        // query params
        if ($authorEmail !== null) {
            $queryParams['author[email]'] = ObjectSerializer::toQueryValue($authorEmail);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                '{' . 'path' . '}',
                ObjectSerializer::toPathValue($path),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteV5ReposOwnerRepoKeysEnableId
     *
     * 停用仓库公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 公钥 ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteV5ReposOwnerRepoKeysEnableId($owner, $repo, $id, $accessToken = null)
    {
        $this->deleteV5ReposOwnerRepoKeysEnableIdWithHttpInfo($owner, $repo, $id, $accessToken);
    }

    /**
     * Operation deleteV5ReposOwnerRepoKeysEnableIdWithHttpInfo
     *
     * 停用仓库公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 公钥 ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteV5ReposOwnerRepoKeysEnableIdWithHttpInfo($owner, $repo, $id, $accessToken = null)
    {
        $returnType = '';
        $request = $this->deleteV5ReposOwnerRepoKeysEnableIdRequest($owner, $repo, $id, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteV5ReposOwnerRepoKeysEnableIdAsync
     *
     * 停用仓库公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 公钥 ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteV5ReposOwnerRepoKeysEnableIdAsync($owner, $repo, $id, $accessToken = null)
    {
        return $this->deleteV5ReposOwnerRepoKeysEnableIdAsyncWithHttpInfo($owner, $repo, $id, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteV5ReposOwnerRepoKeysEnableIdAsyncWithHttpInfo
     *
     * 停用仓库公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 公钥 ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteV5ReposOwnerRepoKeysEnableIdAsyncWithHttpInfo($owner, $repo, $id, $accessToken = null)
    {
        $returnType = '';
        $request = $this->deleteV5ReposOwnerRepoKeysEnableIdRequest($owner, $repo, $id, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteV5ReposOwnerRepoKeysEnableId'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 公钥 ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteV5ReposOwnerRepoKeysEnableIdRequest($owner, $repo, $id, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling deleteV5ReposOwnerRepoKeysEnableId'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling deleteV5ReposOwnerRepoKeysEnableId'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteV5ReposOwnerRepoKeysEnableId'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/keys/enable/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteV5ReposOwnerRepoKeysId
     *
     * 删除一个仓库公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 公钥 ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteV5ReposOwnerRepoKeysId($owner, $repo, $id, $accessToken = null)
    {
        $this->deleteV5ReposOwnerRepoKeysIdWithHttpInfo($owner, $repo, $id, $accessToken);
    }

    /**
     * Operation deleteV5ReposOwnerRepoKeysIdWithHttpInfo
     *
     * 删除一个仓库公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 公钥 ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteV5ReposOwnerRepoKeysIdWithHttpInfo($owner, $repo, $id, $accessToken = null)
    {
        $returnType = '';
        $request = $this->deleteV5ReposOwnerRepoKeysIdRequest($owner, $repo, $id, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteV5ReposOwnerRepoKeysIdAsync
     *
     * 删除一个仓库公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 公钥 ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteV5ReposOwnerRepoKeysIdAsync($owner, $repo, $id, $accessToken = null)
    {
        return $this->deleteV5ReposOwnerRepoKeysIdAsyncWithHttpInfo($owner, $repo, $id, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteV5ReposOwnerRepoKeysIdAsyncWithHttpInfo
     *
     * 删除一个仓库公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 公钥 ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteV5ReposOwnerRepoKeysIdAsyncWithHttpInfo($owner, $repo, $id, $accessToken = null)
    {
        $returnType = '';
        $request = $this->deleteV5ReposOwnerRepoKeysIdRequest($owner, $repo, $id, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteV5ReposOwnerRepoKeysId'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 公钥 ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteV5ReposOwnerRepoKeysIdRequest($owner, $repo, $id, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling deleteV5ReposOwnerRepoKeysId'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling deleteV5ReposOwnerRepoKeysId'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteV5ReposOwnerRepoKeysId'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/keys/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteV5ReposOwnerRepoReleasesId
     *
     * 删除仓库Release
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id id (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteV5ReposOwnerRepoReleasesId($owner, $repo, $id, $accessToken = null)
    {
        $this->deleteV5ReposOwnerRepoReleasesIdWithHttpInfo($owner, $repo, $id, $accessToken);
    }

    /**
     * Operation deleteV5ReposOwnerRepoReleasesIdWithHttpInfo
     *
     * 删除仓库Release
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteV5ReposOwnerRepoReleasesIdWithHttpInfo($owner, $repo, $id, $accessToken = null)
    {
        $returnType = '';
        $request = $this->deleteV5ReposOwnerRepoReleasesIdRequest($owner, $repo, $id, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteV5ReposOwnerRepoReleasesIdAsync
     *
     * 删除仓库Release
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteV5ReposOwnerRepoReleasesIdAsync($owner, $repo, $id, $accessToken = null)
    {
        return $this->deleteV5ReposOwnerRepoReleasesIdAsyncWithHttpInfo($owner, $repo, $id, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteV5ReposOwnerRepoReleasesIdAsyncWithHttpInfo
     *
     * 删除仓库Release
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteV5ReposOwnerRepoReleasesIdAsyncWithHttpInfo($owner, $repo, $id, $accessToken = null)
    {
        $returnType = '';
        $request = $this->deleteV5ReposOwnerRepoReleasesIdRequest($owner, $repo, $id, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteV5ReposOwnerRepoReleasesId'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteV5ReposOwnerRepoReleasesIdRequest($owner, $repo, $id, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling deleteV5ReposOwnerRepoReleasesId'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling deleteV5ReposOwnerRepoReleasesId'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteV5ReposOwnerRepoReleasesId'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/releases/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileId
     *
     * 删除仓库下指定 Release 的指定附件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $releaseId releaseId (required)
     * @param  int $attachFileId attachFileId (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileId($owner, $repo, $releaseId, $attachFileId, $accessToken = null)
    {
        $this->deleteV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdWithHttpInfo($owner, $repo, $releaseId, $attachFileId, $accessToken);
    }

    /**
     * Operation deleteV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdWithHttpInfo
     *
     * 删除仓库下指定 Release 的指定附件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $releaseId (required)
     * @param  int $attachFileId (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdWithHttpInfo($owner, $repo, $releaseId, $attachFileId, $accessToken = null)
    {
        $returnType = '';
        $request = $this->deleteV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdRequest($owner, $repo, $releaseId, $attachFileId, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdAsync
     *
     * 删除仓库下指定 Release 的指定附件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $releaseId (required)
     * @param  int $attachFileId (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdAsync($owner, $repo, $releaseId, $attachFileId, $accessToken = null)
    {
        return $this->deleteV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdAsyncWithHttpInfo($owner, $repo, $releaseId, $attachFileId, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdAsyncWithHttpInfo
     *
     * 删除仓库下指定 Release 的指定附件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $releaseId (required)
     * @param  int $attachFileId (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdAsyncWithHttpInfo($owner, $repo, $releaseId, $attachFileId, $accessToken = null)
    {
        $returnType = '';
        $request = $this->deleteV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdRequest($owner, $repo, $releaseId, $attachFileId, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileId'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $releaseId (required)
     * @param  int $attachFileId (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdRequest($owner, $repo, $releaseId, $attachFileId, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling deleteV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileId'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling deleteV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileId'
            );
        }
        // verify the required parameter 'releaseId' is set
        if ($releaseId === null || (is_array($releaseId) && count($releaseId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $releaseId when calling deleteV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileId'
            );
        }
        // verify the required parameter 'attachFileId' is set
        if ($attachFileId === null || (is_array($attachFileId) && count($attachFileId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachFileId when calling deleteV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileId'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/releases/{release_id}/attach_files/{attach_file_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($releaseId !== null) {
            $resourcePath = str_replace(
                '{' . 'release_id' . '}',
                ObjectSerializer::toPathValue($releaseId),
                $resourcePath
            );
        }
        // path params
        if ($attachFileId !== null) {
            $resourcePath = str_replace(
                '{' . 'attach_file_id' . '}',
                ObjectSerializer::toPathValue($attachFileId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5EnterprisesEnterpriseRepos
     *
     * 获取企业的所有仓库
     *
     * @param  string $enterprise 企业的路径(path/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $search 搜索字符串 (optional)
     * @param  string $type 筛选仓库的类型，可以是 all, public, internal, private。默认: all (optional, default to all)
     * @param  bool $direct 只获取直属仓库，默认: false (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Project[]
     */
    public function getV5EnterprisesEnterpriseRepos($enterprise, $accessToken = null, $search = null, $type = 'all', $direct = null, $page = '1', $perPage = '20')
    {
        list($response) = $this->getV5EnterprisesEnterpriseReposWithHttpInfo($enterprise, $accessToken, $search, $type, $direct, $page, $perPage);
        return $response;
    }

    /**
     * Operation getV5EnterprisesEnterpriseReposWithHttpInfo
     *
     * 获取企业的所有仓库
     *
     * @param  string $enterprise 企业的路径(path/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $search 搜索字符串 (optional)
     * @param  string $type 筛选仓库的类型，可以是 all, public, internal, private。默认: all (optional, default to all)
     * @param  bool $direct 只获取直属仓库，默认: false (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Project[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5EnterprisesEnterpriseReposWithHttpInfo($enterprise, $accessToken = null, $search = null, $type = 'all', $direct = null, $page = '1', $perPage = '20')
    {
        $returnType = '\Gitee\Model\Project[]';
        $request = $this->getV5EnterprisesEnterpriseReposRequest($enterprise, $accessToken, $search, $type, $direct, $page, $perPage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Project[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5EnterprisesEnterpriseReposAsync
     *
     * 获取企业的所有仓库
     *
     * @param  string $enterprise 企业的路径(path/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $search 搜索字符串 (optional)
     * @param  string $type 筛选仓库的类型，可以是 all, public, internal, private。默认: all (optional, default to all)
     * @param  bool $direct 只获取直属仓库，默认: false (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5EnterprisesEnterpriseReposAsync($enterprise, $accessToken = null, $search = null, $type = 'all', $direct = null, $page = '1', $perPage = '20')
    {
        return $this->getV5EnterprisesEnterpriseReposAsyncWithHttpInfo($enterprise, $accessToken, $search, $type, $direct, $page, $perPage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5EnterprisesEnterpriseReposAsyncWithHttpInfo
     *
     * 获取企业的所有仓库
     *
     * @param  string $enterprise 企业的路径(path/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $search 搜索字符串 (optional)
     * @param  string $type 筛选仓库的类型，可以是 all, public, internal, private。默认: all (optional, default to all)
     * @param  bool $direct 只获取直属仓库，默认: false (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5EnterprisesEnterpriseReposAsyncWithHttpInfo($enterprise, $accessToken = null, $search = null, $type = 'all', $direct = null, $page = '1', $perPage = '20')
    {
        $returnType = '\Gitee\Model\Project[]';
        $request = $this->getV5EnterprisesEnterpriseReposRequest($enterprise, $accessToken, $search, $type, $direct, $page, $perPage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5EnterprisesEnterpriseRepos'
     *
     * @param  string $enterprise 企业的路径(path/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $search 搜索字符串 (optional)
     * @param  string $type 筛选仓库的类型，可以是 all, public, internal, private。默认: all (optional, default to all)
     * @param  bool $direct 只获取直属仓库，默认: false (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5EnterprisesEnterpriseReposRequest($enterprise, $accessToken = null, $search = null, $type = 'all', $direct = null, $page = '1', $perPage = '20')
    {
        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling getV5EnterprisesEnterpriseRepos'
            );
        }
        if ($perPage !== null && $perPage > 100) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5EnterprisesEnterpriseRepos, must be smaller than or equal to 100.');
        }
        if ($perPage !== null && $perPage < 1) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5EnterprisesEnterpriseRepos, must be bigger than or equal to 1.');
        }


        $resourcePath = '/v5/enterprises/{enterprise}/repos';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }
        // query params
        if ($search !== null) {
            $queryParams['search'] = ObjectSerializer::toQueryValue($search);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($direct !== null) {
            $queryParams['direct'] = ObjectSerializer::toQueryValue($direct);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($perPage !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($perPage);
        }

        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5OrgsOrgRepos
     *
     * 获取一个组织的仓库
     *
     * @param  string $org 组织的路径(path/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $type 筛选仓库的类型，可以是 all, public, private。默认: all (optional, default to all)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Project[]
     */
    public function getV5OrgsOrgRepos($org, $accessToken = null, $type = 'all', $page = '1', $perPage = '20')
    {
        list($response) = $this->getV5OrgsOrgReposWithHttpInfo($org, $accessToken, $type, $page, $perPage);
        return $response;
    }

    /**
     * Operation getV5OrgsOrgReposWithHttpInfo
     *
     * 获取一个组织的仓库
     *
     * @param  string $org 组织的路径(path/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $type 筛选仓库的类型，可以是 all, public, private。默认: all (optional, default to all)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Project[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5OrgsOrgReposWithHttpInfo($org, $accessToken = null, $type = 'all', $page = '1', $perPage = '20')
    {
        $returnType = '\Gitee\Model\Project[]';
        $request = $this->getV5OrgsOrgReposRequest($org, $accessToken, $type, $page, $perPage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Project[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5OrgsOrgReposAsync
     *
     * 获取一个组织的仓库
     *
     * @param  string $org 组织的路径(path/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $type 筛选仓库的类型，可以是 all, public, private。默认: all (optional, default to all)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5OrgsOrgReposAsync($org, $accessToken = null, $type = 'all', $page = '1', $perPage = '20')
    {
        return $this->getV5OrgsOrgReposAsyncWithHttpInfo($org, $accessToken, $type, $page, $perPage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5OrgsOrgReposAsyncWithHttpInfo
     *
     * 获取一个组织的仓库
     *
     * @param  string $org 组织的路径(path/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $type 筛选仓库的类型，可以是 all, public, private。默认: all (optional, default to all)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5OrgsOrgReposAsyncWithHttpInfo($org, $accessToken = null, $type = 'all', $page = '1', $perPage = '20')
    {
        $returnType = '\Gitee\Model\Project[]';
        $request = $this->getV5OrgsOrgReposRequest($org, $accessToken, $type, $page, $perPage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5OrgsOrgRepos'
     *
     * @param  string $org 组织的路径(path/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $type 筛选仓库的类型，可以是 all, public, private。默认: all (optional, default to all)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5OrgsOrgReposRequest($org, $accessToken = null, $type = 'all', $page = '1', $perPage = '20')
    {
        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling getV5OrgsOrgRepos'
            );
        }
        if ($perPage !== null && $perPage > 100) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5OrgsOrgRepos, must be smaller than or equal to 100.');
        }
        if ($perPage !== null && $perPage < 1) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5OrgsOrgRepos, must be bigger than or equal to 1.');
        }


        $resourcePath = '/v5/orgs/{org}/repos';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($perPage !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($perPage);
        }

        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepo
     *
     * 获取用户的某个仓库
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Project
     */
    public function getV5ReposOwnerRepo($owner, $repo, $accessToken = null)
    {
        list($response) = $this->getV5ReposOwnerRepoWithHttpInfo($owner, $repo, $accessToken);
        return $response;
    }

    /**
     * Operation getV5ReposOwnerRepoWithHttpInfo
     *
     * 获取用户的某个仓库
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Project, HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoWithHttpInfo($owner, $repo, $accessToken = null)
    {
        $returnType = '\Gitee\Model\Project';
        $request = $this->getV5ReposOwnerRepoRequest($owner, $repo, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Project',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoAsync
     *
     * 获取用户的某个仓库
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoAsync($owner, $repo, $accessToken = null)
    {
        return $this->getV5ReposOwnerRepoAsyncWithHttpInfo($owner, $repo, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoAsyncWithHttpInfo
     *
     * 获取用户的某个仓库
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoAsyncWithHttpInfo($owner, $repo, $accessToken = null)
    {
        $returnType = '\Gitee\Model\Project';
        $request = $this->getV5ReposOwnerRepoRequest($owner, $repo, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepo'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoRequest($owner, $repo, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepo'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepo'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoBaiduStatisticKey
     *
     * 获取仓库的百度统计 key
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getV5ReposOwnerRepoBaiduStatisticKey($owner, $repo, $accessToken = null)
    {
        $this->getV5ReposOwnerRepoBaiduStatisticKeyWithHttpInfo($owner, $repo, $accessToken);
    }

    /**
     * Operation getV5ReposOwnerRepoBaiduStatisticKeyWithHttpInfo
     *
     * 获取仓库的百度统计 key
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoBaiduStatisticKeyWithHttpInfo($owner, $repo, $accessToken = null)
    {
        $returnType = '';
        $request = $this->getV5ReposOwnerRepoBaiduStatisticKeyRequest($owner, $repo, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoBaiduStatisticKeyAsync
     *
     * 获取仓库的百度统计 key
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoBaiduStatisticKeyAsync($owner, $repo, $accessToken = null)
    {
        return $this->getV5ReposOwnerRepoBaiduStatisticKeyAsyncWithHttpInfo($owner, $repo, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoBaiduStatisticKeyAsyncWithHttpInfo
     *
     * 获取仓库的百度统计 key
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoBaiduStatisticKeyAsyncWithHttpInfo($owner, $repo, $accessToken = null)
    {
        $returnType = '';
        $request = $this->getV5ReposOwnerRepoBaiduStatisticKeyRequest($owner, $repo, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoBaiduStatisticKey'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoBaiduStatisticKeyRequest($owner, $repo, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoBaiduStatisticKey'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoBaiduStatisticKey'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/baidu_statistic_key';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoBlamePath
     *
     * Blame
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径（1 MB 以内的文件文件） (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag 或 commit。默认: 仓库的默认分支（通常是 master） (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Blame[]
     */
    public function getV5ReposOwnerRepoBlamePath($owner, $repo, $path, $accessToken = null, $ref = null)
    {
        list($response) = $this->getV5ReposOwnerRepoBlamePathWithHttpInfo($owner, $repo, $path, $accessToken, $ref);
        return $response;
    }

    /**
     * Operation getV5ReposOwnerRepoBlamePathWithHttpInfo
     *
     * Blame
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径（1 MB 以内的文件文件） (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag 或 commit。默认: 仓库的默认分支（通常是 master） (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Blame[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoBlamePathWithHttpInfo($owner, $repo, $path, $accessToken = null, $ref = null)
    {
        $returnType = '\Gitee\Model\Blame[]';
        $request = $this->getV5ReposOwnerRepoBlamePathRequest($owner, $repo, $path, $accessToken, $ref);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Blame[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoBlamePathAsync
     *
     * Blame
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径（1 MB 以内的文件文件） (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag 或 commit。默认: 仓库的默认分支（通常是 master） (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoBlamePathAsync($owner, $repo, $path, $accessToken = null, $ref = null)
    {
        return $this->getV5ReposOwnerRepoBlamePathAsyncWithHttpInfo($owner, $repo, $path, $accessToken, $ref)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoBlamePathAsyncWithHttpInfo
     *
     * Blame
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径（1 MB 以内的文件文件） (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag 或 commit。默认: 仓库的默认分支（通常是 master） (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoBlamePathAsyncWithHttpInfo($owner, $repo, $path, $accessToken = null, $ref = null)
    {
        $returnType = '\Gitee\Model\Blame[]';
        $request = $this->getV5ReposOwnerRepoBlamePathRequest($owner, $repo, $path, $accessToken, $ref);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoBlamePath'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径（1 MB 以内的文件文件） (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag 或 commit。默认: 仓库的默认分支（通常是 master） (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoBlamePathRequest($owner, $repo, $path, $accessToken = null, $ref = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoBlamePath'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoBlamePath'
            );
        }
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getV5ReposOwnerRepoBlamePath'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/blame/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }
        // query params
        if ($ref !== null) {
            $queryParams['ref'] = ObjectSerializer::toQueryValue($ref);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                '{' . 'path' . '}',
                ObjectSerializer::toPathValue($path),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoBranches
     *
     * 获取所有分支
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $sort 排序字段 (optional, default to name)
     * @param  string $direction 排序方向 (optional, default to asc)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Branch[]
     */
    public function getV5ReposOwnerRepoBranches($owner, $repo, $accessToken = null, $sort = 'name', $direction = 'asc', $page = '1', $perPage = null)
    {
        list($response) = $this->getV5ReposOwnerRepoBranchesWithHttpInfo($owner, $repo, $accessToken, $sort, $direction, $page, $perPage);
        return $response;
    }

    /**
     * Operation getV5ReposOwnerRepoBranchesWithHttpInfo
     *
     * 获取所有分支
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $sort 排序字段 (optional, default to name)
     * @param  string $direction 排序方向 (optional, default to asc)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Branch[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoBranchesWithHttpInfo($owner, $repo, $accessToken = null, $sort = 'name', $direction = 'asc', $page = '1', $perPage = null)
    {
        $returnType = '\Gitee\Model\Branch[]';
        $request = $this->getV5ReposOwnerRepoBranchesRequest($owner, $repo, $accessToken, $sort, $direction, $page, $perPage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Branch[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoBranchesAsync
     *
     * 获取所有分支
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $sort 排序字段 (optional, default to name)
     * @param  string $direction 排序方向 (optional, default to asc)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoBranchesAsync($owner, $repo, $accessToken = null, $sort = 'name', $direction = 'asc', $page = '1', $perPage = null)
    {
        return $this->getV5ReposOwnerRepoBranchesAsyncWithHttpInfo($owner, $repo, $accessToken, $sort, $direction, $page, $perPage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoBranchesAsyncWithHttpInfo
     *
     * 获取所有分支
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $sort 排序字段 (optional, default to name)
     * @param  string $direction 排序方向 (optional, default to asc)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoBranchesAsyncWithHttpInfo($owner, $repo, $accessToken = null, $sort = 'name', $direction = 'asc', $page = '1', $perPage = null)
    {
        $returnType = '\Gitee\Model\Branch[]';
        $request = $this->getV5ReposOwnerRepoBranchesRequest($owner, $repo, $accessToken, $sort, $direction, $page, $perPage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoBranches'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $sort 排序字段 (optional, default to name)
     * @param  string $direction 排序方向 (optional, default to asc)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoBranchesRequest($owner, $repo, $accessToken = null, $sort = 'name', $direction = 'asc', $page = '1', $perPage = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoBranches'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoBranches'
            );
        }
        if ($perPage !== null && $perPage > 100) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5ReposOwnerRepoBranches, must be smaller than or equal to 100.');
        }
        if ($perPage !== null && $perPage < 1) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5ReposOwnerRepoBranches, must be bigger than or equal to 1.');
        }


        $resourcePath = '/v5/repos/{owner}/{repo}/branches';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($direction !== null) {
            $queryParams['direction'] = ObjectSerializer::toQueryValue($direction);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($perPage !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($perPage);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoBranchesBranch
     *
     * 获取单个分支
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $branch 分支名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\CompleteBranch
     */
    public function getV5ReposOwnerRepoBranchesBranch($owner, $repo, $branch, $accessToken = null)
    {
        list($response) = $this->getV5ReposOwnerRepoBranchesBranchWithHttpInfo($owner, $repo, $branch, $accessToken);
        return $response;
    }

    /**
     * Operation getV5ReposOwnerRepoBranchesBranchWithHttpInfo
     *
     * 获取单个分支
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $branch 分支名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\CompleteBranch, HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoBranchesBranchWithHttpInfo($owner, $repo, $branch, $accessToken = null)
    {
        $returnType = '\Gitee\Model\CompleteBranch';
        $request = $this->getV5ReposOwnerRepoBranchesBranchRequest($owner, $repo, $branch, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\CompleteBranch',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoBranchesBranchAsync
     *
     * 获取单个分支
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $branch 分支名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoBranchesBranchAsync($owner, $repo, $branch, $accessToken = null)
    {
        return $this->getV5ReposOwnerRepoBranchesBranchAsyncWithHttpInfo($owner, $repo, $branch, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoBranchesBranchAsyncWithHttpInfo
     *
     * 获取单个分支
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $branch 分支名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoBranchesBranchAsyncWithHttpInfo($owner, $repo, $branch, $accessToken = null)
    {
        $returnType = '\Gitee\Model\CompleteBranch';
        $request = $this->getV5ReposOwnerRepoBranchesBranchRequest($owner, $repo, $branch, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoBranchesBranch'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $branch 分支名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoBranchesBranchRequest($owner, $repo, $branch, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoBranchesBranch'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoBranchesBranch'
            );
        }
        // verify the required parameter 'branch' is set
        if ($branch === null || (is_array($branch) && count($branch) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $branch when calling getV5ReposOwnerRepoBranchesBranch'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/branches/{branch}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($branch !== null) {
            $resourcePath = str_replace(
                '{' . 'branch' . '}',
                ObjectSerializer::toPathValue($branch),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoCollaborators
     *
     * 获取仓库的所有成员
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\ProjectMember[]
     */
    public function getV5ReposOwnerRepoCollaborators($owner, $repo, $accessToken = null, $page = '1', $perPage = '20')
    {
        list($response) = $this->getV5ReposOwnerRepoCollaboratorsWithHttpInfo($owner, $repo, $accessToken, $page, $perPage);
        return $response;
    }

    /**
     * Operation getV5ReposOwnerRepoCollaboratorsWithHttpInfo
     *
     * 获取仓库的所有成员
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\ProjectMember[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoCollaboratorsWithHttpInfo($owner, $repo, $accessToken = null, $page = '1', $perPage = '20')
    {
        $returnType = '\Gitee\Model\ProjectMember[]';
        $request = $this->getV5ReposOwnerRepoCollaboratorsRequest($owner, $repo, $accessToken, $page, $perPage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\ProjectMember[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoCollaboratorsAsync
     *
     * 获取仓库的所有成员
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoCollaboratorsAsync($owner, $repo, $accessToken = null, $page = '1', $perPage = '20')
    {
        return $this->getV5ReposOwnerRepoCollaboratorsAsyncWithHttpInfo($owner, $repo, $accessToken, $page, $perPage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoCollaboratorsAsyncWithHttpInfo
     *
     * 获取仓库的所有成员
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoCollaboratorsAsyncWithHttpInfo($owner, $repo, $accessToken = null, $page = '1', $perPage = '20')
    {
        $returnType = '\Gitee\Model\ProjectMember[]';
        $request = $this->getV5ReposOwnerRepoCollaboratorsRequest($owner, $repo, $accessToken, $page, $perPage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoCollaborators'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoCollaboratorsRequest($owner, $repo, $accessToken = null, $page = '1', $perPage = '20')
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoCollaborators'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoCollaborators'
            );
        }
        if ($perPage !== null && $perPage > 100) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5ReposOwnerRepoCollaborators, must be smaller than or equal to 100.');
        }
        if ($perPage !== null && $perPage < 1) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5ReposOwnerRepoCollaborators, must be bigger than or equal to 1.');
        }


        $resourcePath = '/v5/repos/{owner}/{repo}/collaborators';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($perPage !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($perPage);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoCollaboratorsUsername
     *
     * 判断用户是否为仓库成员
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $username 用户名(username/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getV5ReposOwnerRepoCollaboratorsUsername($owner, $repo, $username, $accessToken = null)
    {
        $this->getV5ReposOwnerRepoCollaboratorsUsernameWithHttpInfo($owner, $repo, $username, $accessToken);
    }

    /**
     * Operation getV5ReposOwnerRepoCollaboratorsUsernameWithHttpInfo
     *
     * 判断用户是否为仓库成员
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $username 用户名(username/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoCollaboratorsUsernameWithHttpInfo($owner, $repo, $username, $accessToken = null)
    {
        $returnType = '';
        $request = $this->getV5ReposOwnerRepoCollaboratorsUsernameRequest($owner, $repo, $username, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoCollaboratorsUsernameAsync
     *
     * 判断用户是否为仓库成员
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $username 用户名(username/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoCollaboratorsUsernameAsync($owner, $repo, $username, $accessToken = null)
    {
        return $this->getV5ReposOwnerRepoCollaboratorsUsernameAsyncWithHttpInfo($owner, $repo, $username, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoCollaboratorsUsernameAsyncWithHttpInfo
     *
     * 判断用户是否为仓库成员
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $username 用户名(username/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoCollaboratorsUsernameAsyncWithHttpInfo($owner, $repo, $username, $accessToken = null)
    {
        $returnType = '';
        $request = $this->getV5ReposOwnerRepoCollaboratorsUsernameRequest($owner, $repo, $username, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoCollaboratorsUsername'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $username 用户名(username/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoCollaboratorsUsernameRequest($owner, $repo, $username, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoCollaboratorsUsername'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoCollaboratorsUsername'
            );
        }
        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling getV5ReposOwnerRepoCollaboratorsUsername'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/collaborators/{username}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoCollaboratorsUsernamePermission
     *
     * 查看仓库成员的权限
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $username 用户名(username/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\ProjectMemberPermission
     */
    public function getV5ReposOwnerRepoCollaboratorsUsernamePermission($owner, $repo, $username, $accessToken = null)
    {
        list($response) = $this->getV5ReposOwnerRepoCollaboratorsUsernamePermissionWithHttpInfo($owner, $repo, $username, $accessToken);
        return $response;
    }

    /**
     * Operation getV5ReposOwnerRepoCollaboratorsUsernamePermissionWithHttpInfo
     *
     * 查看仓库成员的权限
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $username 用户名(username/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\ProjectMemberPermission, HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoCollaboratorsUsernamePermissionWithHttpInfo($owner, $repo, $username, $accessToken = null)
    {
        $returnType = '\Gitee\Model\ProjectMemberPermission';
        $request = $this->getV5ReposOwnerRepoCollaboratorsUsernamePermissionRequest($owner, $repo, $username, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\ProjectMemberPermission',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoCollaboratorsUsernamePermissionAsync
     *
     * 查看仓库成员的权限
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $username 用户名(username/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoCollaboratorsUsernamePermissionAsync($owner, $repo, $username, $accessToken = null)
    {
        return $this->getV5ReposOwnerRepoCollaboratorsUsernamePermissionAsyncWithHttpInfo($owner, $repo, $username, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoCollaboratorsUsernamePermissionAsyncWithHttpInfo
     *
     * 查看仓库成员的权限
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $username 用户名(username/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoCollaboratorsUsernamePermissionAsyncWithHttpInfo($owner, $repo, $username, $accessToken = null)
    {
        $returnType = '\Gitee\Model\ProjectMemberPermission';
        $request = $this->getV5ReposOwnerRepoCollaboratorsUsernamePermissionRequest($owner, $repo, $username, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoCollaboratorsUsernamePermission'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $username 用户名(username/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoCollaboratorsUsernamePermissionRequest($owner, $repo, $username, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoCollaboratorsUsernamePermission'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoCollaboratorsUsernamePermission'
            );
        }
        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling getV5ReposOwnerRepoCollaboratorsUsernamePermission'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/collaborators/{username}/permission';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoComments
     *
     * 获取仓库的 Commit 评论
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     * @param  string $order 排序顺序: asc(default),desc (optional, default to asc)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Note[]
     */
    public function getV5ReposOwnerRepoComments($owner, $repo, $accessToken = null, $page = '1', $perPage = '20', $order = 'asc')
    {
        list($response) = $this->getV5ReposOwnerRepoCommentsWithHttpInfo($owner, $repo, $accessToken, $page, $perPage, $order);
        return $response;
    }

    /**
     * Operation getV5ReposOwnerRepoCommentsWithHttpInfo
     *
     * 获取仓库的 Commit 评论
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     * @param  string $order 排序顺序: asc(default),desc (optional, default to asc)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Note[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoCommentsWithHttpInfo($owner, $repo, $accessToken = null, $page = '1', $perPage = '20', $order = 'asc')
    {
        $returnType = '\Gitee\Model\Note[]';
        $request = $this->getV5ReposOwnerRepoCommentsRequest($owner, $repo, $accessToken, $page, $perPage, $order);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Note[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoCommentsAsync
     *
     * 获取仓库的 Commit 评论
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     * @param  string $order 排序顺序: asc(default),desc (optional, default to asc)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoCommentsAsync($owner, $repo, $accessToken = null, $page = '1', $perPage = '20', $order = 'asc')
    {
        return $this->getV5ReposOwnerRepoCommentsAsyncWithHttpInfo($owner, $repo, $accessToken, $page, $perPage, $order)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoCommentsAsyncWithHttpInfo
     *
     * 获取仓库的 Commit 评论
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     * @param  string $order 排序顺序: asc(default),desc (optional, default to asc)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoCommentsAsyncWithHttpInfo($owner, $repo, $accessToken = null, $page = '1', $perPage = '20', $order = 'asc')
    {
        $returnType = '\Gitee\Model\Note[]';
        $request = $this->getV5ReposOwnerRepoCommentsRequest($owner, $repo, $accessToken, $page, $perPage, $order);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoComments'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     * @param  string $order 排序顺序: asc(default),desc (optional, default to asc)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoCommentsRequest($owner, $repo, $accessToken = null, $page = '1', $perPage = '20', $order = 'asc')
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoComments'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoComments'
            );
        }
        if ($perPage !== null && $perPage > 100) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5ReposOwnerRepoComments, must be smaller than or equal to 100.');
        }
        if ($perPage !== null && $perPage < 1) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5ReposOwnerRepoComments, must be bigger than or equal to 1.');
        }


        $resourcePath = '/v5/repos/{owner}/{repo}/comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($perPage !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($perPage);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoCommentsId
     *
     * 获取仓库的某条Commit评论
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 评论的ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Note
     */
    public function getV5ReposOwnerRepoCommentsId($owner, $repo, $id, $accessToken = null)
    {
        list($response) = $this->getV5ReposOwnerRepoCommentsIdWithHttpInfo($owner, $repo, $id, $accessToken);
        return $response;
    }

    /**
     * Operation getV5ReposOwnerRepoCommentsIdWithHttpInfo
     *
     * 获取仓库的某条Commit评论
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 评论的ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Note, HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoCommentsIdWithHttpInfo($owner, $repo, $id, $accessToken = null)
    {
        $returnType = '\Gitee\Model\Note';
        $request = $this->getV5ReposOwnerRepoCommentsIdRequest($owner, $repo, $id, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoCommentsIdAsync
     *
     * 获取仓库的某条Commit评论
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 评论的ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoCommentsIdAsync($owner, $repo, $id, $accessToken = null)
    {
        return $this->getV5ReposOwnerRepoCommentsIdAsyncWithHttpInfo($owner, $repo, $id, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoCommentsIdAsyncWithHttpInfo
     *
     * 获取仓库的某条Commit评论
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 评论的ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoCommentsIdAsyncWithHttpInfo($owner, $repo, $id, $accessToken = null)
    {
        $returnType = '\Gitee\Model\Note';
        $request = $this->getV5ReposOwnerRepoCommentsIdRequest($owner, $repo, $id, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoCommentsId'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 评论的ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoCommentsIdRequest($owner, $repo, $id, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoCommentsId'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoCommentsId'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getV5ReposOwnerRepoCommentsId'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/comments/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoCommits
     *
     * 仓库的所有提交
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $sha 提交起始的SHA值或者分支名. 默认: 仓库的默认分支 (optional)
     * @param  string $path 包含该文件的提交 (optional)
     * @param  string $author 提交作者的邮箱或个人空间地址(username/login) (optional)
     * @param  string $since 提交的起始时间，时间格式为 ISO 8601 (optional)
     * @param  string $until 提交的最后时间，时间格式为 ISO 8601 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\RepoCommit[]
     */
    public function getV5ReposOwnerRepoCommits($owner, $repo, $accessToken = null, $sha = null, $path = null, $author = null, $since = null, $until = null, $page = '1', $perPage = '20')
    {
        list($response) = $this->getV5ReposOwnerRepoCommitsWithHttpInfo($owner, $repo, $accessToken, $sha, $path, $author, $since, $until, $page, $perPage);
        return $response;
    }

    /**
     * Operation getV5ReposOwnerRepoCommitsWithHttpInfo
     *
     * 仓库的所有提交
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $sha 提交起始的SHA值或者分支名. 默认: 仓库的默认分支 (optional)
     * @param  string $path 包含该文件的提交 (optional)
     * @param  string $author 提交作者的邮箱或个人空间地址(username/login) (optional)
     * @param  string $since 提交的起始时间，时间格式为 ISO 8601 (optional)
     * @param  string $until 提交的最后时间，时间格式为 ISO 8601 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\RepoCommit[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoCommitsWithHttpInfo($owner, $repo, $accessToken = null, $sha = null, $path = null, $author = null, $since = null, $until = null, $page = '1', $perPage = '20')
    {
        $returnType = '\Gitee\Model\RepoCommit[]';
        $request = $this->getV5ReposOwnerRepoCommitsRequest($owner, $repo, $accessToken, $sha, $path, $author, $since, $until, $page, $perPage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\RepoCommit[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoCommitsAsync
     *
     * 仓库的所有提交
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $sha 提交起始的SHA值或者分支名. 默认: 仓库的默认分支 (optional)
     * @param  string $path 包含该文件的提交 (optional)
     * @param  string $author 提交作者的邮箱或个人空间地址(username/login) (optional)
     * @param  string $since 提交的起始时间，时间格式为 ISO 8601 (optional)
     * @param  string $until 提交的最后时间，时间格式为 ISO 8601 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoCommitsAsync($owner, $repo, $accessToken = null, $sha = null, $path = null, $author = null, $since = null, $until = null, $page = '1', $perPage = '20')
    {
        return $this->getV5ReposOwnerRepoCommitsAsyncWithHttpInfo($owner, $repo, $accessToken, $sha, $path, $author, $since, $until, $page, $perPage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoCommitsAsyncWithHttpInfo
     *
     * 仓库的所有提交
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $sha 提交起始的SHA值或者分支名. 默认: 仓库的默认分支 (optional)
     * @param  string $path 包含该文件的提交 (optional)
     * @param  string $author 提交作者的邮箱或个人空间地址(username/login) (optional)
     * @param  string $since 提交的起始时间，时间格式为 ISO 8601 (optional)
     * @param  string $until 提交的最后时间，时间格式为 ISO 8601 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoCommitsAsyncWithHttpInfo($owner, $repo, $accessToken = null, $sha = null, $path = null, $author = null, $since = null, $until = null, $page = '1', $perPage = '20')
    {
        $returnType = '\Gitee\Model\RepoCommit[]';
        $request = $this->getV5ReposOwnerRepoCommitsRequest($owner, $repo, $accessToken, $sha, $path, $author, $since, $until, $page, $perPage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoCommits'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $sha 提交起始的SHA值或者分支名. 默认: 仓库的默认分支 (optional)
     * @param  string $path 包含该文件的提交 (optional)
     * @param  string $author 提交作者的邮箱或个人空间地址(username/login) (optional)
     * @param  string $since 提交的起始时间，时间格式为 ISO 8601 (optional)
     * @param  string $until 提交的最后时间，时间格式为 ISO 8601 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoCommitsRequest($owner, $repo, $accessToken = null, $sha = null, $path = null, $author = null, $since = null, $until = null, $page = '1', $perPage = '20')
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoCommits'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoCommits'
            );
        }
        if ($perPage !== null && $perPage > 100) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5ReposOwnerRepoCommits, must be smaller than or equal to 100.');
        }
        if ($perPage !== null && $perPage < 1) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5ReposOwnerRepoCommits, must be bigger than or equal to 1.');
        }


        $resourcePath = '/v5/repos/{owner}/{repo}/commits';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }
        // query params
        if ($sha !== null) {
            $queryParams['sha'] = ObjectSerializer::toQueryValue($sha);
        }
        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($author !== null) {
            $queryParams['author'] = ObjectSerializer::toQueryValue($author);
        }
        // query params
        if ($since !== null) {
            $queryParams['since'] = ObjectSerializer::toQueryValue($since);
        }
        // query params
        if ($until !== null) {
            $queryParams['until'] = ObjectSerializer::toQueryValue($until);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($perPage !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($perPage);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoCommitsRefComments
     *
     * 获取单个Commit的评论
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $ref Commit的Reference (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Note[]
     */
    public function getV5ReposOwnerRepoCommitsRefComments($owner, $repo, $ref, $accessToken = null, $page = '1', $perPage = '20')
    {
        list($response) = $this->getV5ReposOwnerRepoCommitsRefCommentsWithHttpInfo($owner, $repo, $ref, $accessToken, $page, $perPage);
        return $response;
    }

    /**
     * Operation getV5ReposOwnerRepoCommitsRefCommentsWithHttpInfo
     *
     * 获取单个Commit的评论
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $ref Commit的Reference (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Note[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoCommitsRefCommentsWithHttpInfo($owner, $repo, $ref, $accessToken = null, $page = '1', $perPage = '20')
    {
        $returnType = '\Gitee\Model\Note[]';
        $request = $this->getV5ReposOwnerRepoCommitsRefCommentsRequest($owner, $repo, $ref, $accessToken, $page, $perPage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Note[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoCommitsRefCommentsAsync
     *
     * 获取单个Commit的评论
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $ref Commit的Reference (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoCommitsRefCommentsAsync($owner, $repo, $ref, $accessToken = null, $page = '1', $perPage = '20')
    {
        return $this->getV5ReposOwnerRepoCommitsRefCommentsAsyncWithHttpInfo($owner, $repo, $ref, $accessToken, $page, $perPage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoCommitsRefCommentsAsyncWithHttpInfo
     *
     * 获取单个Commit的评论
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $ref Commit的Reference (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoCommitsRefCommentsAsyncWithHttpInfo($owner, $repo, $ref, $accessToken = null, $page = '1', $perPage = '20')
    {
        $returnType = '\Gitee\Model\Note[]';
        $request = $this->getV5ReposOwnerRepoCommitsRefCommentsRequest($owner, $repo, $ref, $accessToken, $page, $perPage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoCommitsRefComments'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $ref Commit的Reference (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoCommitsRefCommentsRequest($owner, $repo, $ref, $accessToken = null, $page = '1', $perPage = '20')
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoCommitsRefComments'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoCommitsRefComments'
            );
        }
        // verify the required parameter 'ref' is set
        if ($ref === null || (is_array($ref) && count($ref) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ref when calling getV5ReposOwnerRepoCommitsRefComments'
            );
        }
        if ($perPage !== null && $perPage > 100) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5ReposOwnerRepoCommitsRefComments, must be smaller than or equal to 100.');
        }
        if ($perPage !== null && $perPage < 1) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5ReposOwnerRepoCommitsRefComments, must be bigger than or equal to 1.');
        }


        $resourcePath = '/v5/repos/{owner}/{repo}/commits/{ref}/comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($perPage !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($perPage);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($ref !== null) {
            $resourcePath = str_replace(
                '{' . 'ref' . '}',
                ObjectSerializer::toPathValue($ref),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoCommitsSha
     *
     * 仓库的某个提交
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $sha 提交的SHA值或者分支名 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\RepoCommitWithFiles
     */
    public function getV5ReposOwnerRepoCommitsSha($owner, $repo, $sha, $accessToken = null)
    {
        list($response) = $this->getV5ReposOwnerRepoCommitsShaWithHttpInfo($owner, $repo, $sha, $accessToken);
        return $response;
    }

    /**
     * Operation getV5ReposOwnerRepoCommitsShaWithHttpInfo
     *
     * 仓库的某个提交
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $sha 提交的SHA值或者分支名 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\RepoCommitWithFiles, HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoCommitsShaWithHttpInfo($owner, $repo, $sha, $accessToken = null)
    {
        $returnType = '\Gitee\Model\RepoCommitWithFiles';
        $request = $this->getV5ReposOwnerRepoCommitsShaRequest($owner, $repo, $sha, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\RepoCommitWithFiles',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoCommitsShaAsync
     *
     * 仓库的某个提交
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $sha 提交的SHA值或者分支名 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoCommitsShaAsync($owner, $repo, $sha, $accessToken = null)
    {
        return $this->getV5ReposOwnerRepoCommitsShaAsyncWithHttpInfo($owner, $repo, $sha, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoCommitsShaAsyncWithHttpInfo
     *
     * 仓库的某个提交
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $sha 提交的SHA值或者分支名 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoCommitsShaAsyncWithHttpInfo($owner, $repo, $sha, $accessToken = null)
    {
        $returnType = '\Gitee\Model\RepoCommitWithFiles';
        $request = $this->getV5ReposOwnerRepoCommitsShaRequest($owner, $repo, $sha, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoCommitsSha'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $sha 提交的SHA值或者分支名 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoCommitsShaRequest($owner, $repo, $sha, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoCommitsSha'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoCommitsSha'
            );
        }
        // verify the required parameter 'sha' is set
        if ($sha === null || (is_array($sha) && count($sha) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sha when calling getV5ReposOwnerRepoCommitsSha'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/commits/{sha}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($sha !== null) {
            $resourcePath = str_replace(
                '{' . 'sha' . '}',
                ObjectSerializer::toPathValue($sha),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoCompareBaseHead
     *
     * Commits 对比
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $base 对比的起点。Commit SHA、分支名或标签名 (required)
     * @param  string $head 对比的终点。Commit SHA、分支名或标签名 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  bool $straight 是否直对比。默认 false (optional)
     * @param  string $suffix 按照文件后缀过滤文件，如 &#x60;.txt&#x60;。只影响 &#x60;files&#x60; (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Compare
     */
    public function getV5ReposOwnerRepoCompareBaseHead($owner, $repo, $base, $head, $accessToken = null, $straight = null, $suffix = null)
    {
        list($response) = $this->getV5ReposOwnerRepoCompareBaseHeadWithHttpInfo($owner, $repo, $base, $head, $accessToken, $straight, $suffix);
        return $response;
    }

    /**
     * Operation getV5ReposOwnerRepoCompareBaseHeadWithHttpInfo
     *
     * Commits 对比
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $base 对比的起点。Commit SHA、分支名或标签名 (required)
     * @param  string $head 对比的终点。Commit SHA、分支名或标签名 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  bool $straight 是否直对比。默认 false (optional)
     * @param  string $suffix 按照文件后缀过滤文件，如 &#x60;.txt&#x60;。只影响 &#x60;files&#x60; (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Compare, HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoCompareBaseHeadWithHttpInfo($owner, $repo, $base, $head, $accessToken = null, $straight = null, $suffix = null)
    {
        $returnType = '\Gitee\Model\Compare';
        $request = $this->getV5ReposOwnerRepoCompareBaseHeadRequest($owner, $repo, $base, $head, $accessToken, $straight, $suffix);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Compare',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoCompareBaseHeadAsync
     *
     * Commits 对比
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $base 对比的起点。Commit SHA、分支名或标签名 (required)
     * @param  string $head 对比的终点。Commit SHA、分支名或标签名 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  bool $straight 是否直对比。默认 false (optional)
     * @param  string $suffix 按照文件后缀过滤文件，如 &#x60;.txt&#x60;。只影响 &#x60;files&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoCompareBaseHeadAsync($owner, $repo, $base, $head, $accessToken = null, $straight = null, $suffix = null)
    {
        return $this->getV5ReposOwnerRepoCompareBaseHeadAsyncWithHttpInfo($owner, $repo, $base, $head, $accessToken, $straight, $suffix)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoCompareBaseHeadAsyncWithHttpInfo
     *
     * Commits 对比
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $base 对比的起点。Commit SHA、分支名或标签名 (required)
     * @param  string $head 对比的终点。Commit SHA、分支名或标签名 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  bool $straight 是否直对比。默认 false (optional)
     * @param  string $suffix 按照文件后缀过滤文件，如 &#x60;.txt&#x60;。只影响 &#x60;files&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoCompareBaseHeadAsyncWithHttpInfo($owner, $repo, $base, $head, $accessToken = null, $straight = null, $suffix = null)
    {
        $returnType = '\Gitee\Model\Compare';
        $request = $this->getV5ReposOwnerRepoCompareBaseHeadRequest($owner, $repo, $base, $head, $accessToken, $straight, $suffix);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoCompareBaseHead'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $base 对比的起点。Commit SHA、分支名或标签名 (required)
     * @param  string $head 对比的终点。Commit SHA、分支名或标签名 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  bool $straight 是否直对比。默认 false (optional)
     * @param  string $suffix 按照文件后缀过滤文件，如 &#x60;.txt&#x60;。只影响 &#x60;files&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoCompareBaseHeadRequest($owner, $repo, $base, $head, $accessToken = null, $straight = null, $suffix = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoCompareBaseHead'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoCompareBaseHead'
            );
        }
        // verify the required parameter 'base' is set
        if ($base === null || (is_array($base) && count($base) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $base when calling getV5ReposOwnerRepoCompareBaseHead'
            );
        }
        // verify the required parameter 'head' is set
        if ($head === null || (is_array($head) && count($head) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $head when calling getV5ReposOwnerRepoCompareBaseHead'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/compare/{base}...{head}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }
        // query params
        if ($straight !== null) {
            $queryParams['straight'] = ObjectSerializer::toQueryValue($straight);
        }
        // query params
        if ($suffix !== null) {
            $queryParams['suffix'] = ObjectSerializer::toQueryValue($suffix);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($base !== null) {
            $resourcePath = str_replace(
                '{' . 'base' . '}',
                ObjectSerializer::toPathValue($base),
                $resourcePath
            );
        }
        // path params
        if ($head !== null) {
            $resourcePath = str_replace(
                '{' . 'head' . '}',
                ObjectSerializer::toPathValue($head),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoContentsPath
     *
     * 获取仓库具体路径下的内容
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag或commit。默认: 仓库的默认分支(通常是master) (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Content[]
     */
    public function getV5ReposOwnerRepoContentsPath($owner, $repo, $path, $accessToken = null, $ref = null)
    {
        list($response) = $this->getV5ReposOwnerRepoContentsPathWithHttpInfo($owner, $repo, $path, $accessToken, $ref);
        return $response;
    }

    /**
     * Operation getV5ReposOwnerRepoContentsPathWithHttpInfo
     *
     * 获取仓库具体路径下的内容
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag或commit。默认: 仓库的默认分支(通常是master) (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Content[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoContentsPathWithHttpInfo($owner, $repo, $path, $accessToken = null, $ref = null)
    {
        $returnType = '\Gitee\Model\Content[]';
        $request = $this->getV5ReposOwnerRepoContentsPathRequest($owner, $repo, $path, $accessToken, $ref);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Content[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoContentsPathAsync
     *
     * 获取仓库具体路径下的内容
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag或commit。默认: 仓库的默认分支(通常是master) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoContentsPathAsync($owner, $repo, $path, $accessToken = null, $ref = null)
    {
        return $this->getV5ReposOwnerRepoContentsPathAsyncWithHttpInfo($owner, $repo, $path, $accessToken, $ref)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoContentsPathAsyncWithHttpInfo
     *
     * 获取仓库具体路径下的内容
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag或commit。默认: 仓库的默认分支(通常是master) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoContentsPathAsyncWithHttpInfo($owner, $repo, $path, $accessToken = null, $ref = null)
    {
        $returnType = '\Gitee\Model\Content[]';
        $request = $this->getV5ReposOwnerRepoContentsPathRequest($owner, $repo, $path, $accessToken, $ref);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoContentsPath'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag或commit。默认: 仓库的默认分支(通常是master) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoContentsPathRequest($owner, $repo, $path, $accessToken = null, $ref = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoContentsPath'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoContentsPath'
            );
        }
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getV5ReposOwnerRepoContentsPath'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/contents(/{path})';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }
        // query params
        if ($ref !== null) {
            $queryParams['ref'] = ObjectSerializer::toQueryValue($ref);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                '{' . 'path' . '}',
                ObjectSerializer::toPathValue($path),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoContributors
     *
     * 获取仓库贡献者
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $type 贡献者类型 (optional, default to committers)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Contributor[]
     */
    public function getV5ReposOwnerRepoContributors($owner, $repo, $accessToken = null, $type = 'committers')
    {
        list($response) = $this->getV5ReposOwnerRepoContributorsWithHttpInfo($owner, $repo, $accessToken, $type);
        return $response;
    }

    /**
     * Operation getV5ReposOwnerRepoContributorsWithHttpInfo
     *
     * 获取仓库贡献者
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $type 贡献者类型 (optional, default to committers)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Contributor[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoContributorsWithHttpInfo($owner, $repo, $accessToken = null, $type = 'committers')
    {
        $returnType = '\Gitee\Model\Contributor[]';
        $request = $this->getV5ReposOwnerRepoContributorsRequest($owner, $repo, $accessToken, $type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Contributor[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoContributorsAsync
     *
     * 获取仓库贡献者
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $type 贡献者类型 (optional, default to committers)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoContributorsAsync($owner, $repo, $accessToken = null, $type = 'committers')
    {
        return $this->getV5ReposOwnerRepoContributorsAsyncWithHttpInfo($owner, $repo, $accessToken, $type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoContributorsAsyncWithHttpInfo
     *
     * 获取仓库贡献者
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $type 贡献者类型 (optional, default to committers)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoContributorsAsyncWithHttpInfo($owner, $repo, $accessToken = null, $type = 'committers')
    {
        $returnType = '\Gitee\Model\Contributor[]';
        $request = $this->getV5ReposOwnerRepoContributorsRequest($owner, $repo, $accessToken, $type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoContributors'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $type 贡献者类型 (optional, default to committers)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoContributorsRequest($owner, $repo, $accessToken = null, $type = 'committers')
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoContributors'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoContributors'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/contributors';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoForks
     *
     * 查看仓库的Forks
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $sort 排序方式: fork的时间(newest, oldest)，star的人数(stargazers) (optional, default to newest)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Project[]
     */
    public function getV5ReposOwnerRepoForks($owner, $repo, $accessToken = null, $sort = 'newest', $page = '1', $perPage = '20')
    {
        list($response) = $this->getV5ReposOwnerRepoForksWithHttpInfo($owner, $repo, $accessToken, $sort, $page, $perPage);
        return $response;
    }

    /**
     * Operation getV5ReposOwnerRepoForksWithHttpInfo
     *
     * 查看仓库的Forks
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $sort 排序方式: fork的时间(newest, oldest)，star的人数(stargazers) (optional, default to newest)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Project[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoForksWithHttpInfo($owner, $repo, $accessToken = null, $sort = 'newest', $page = '1', $perPage = '20')
    {
        $returnType = '\Gitee\Model\Project[]';
        $request = $this->getV5ReposOwnerRepoForksRequest($owner, $repo, $accessToken, $sort, $page, $perPage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Project[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoForksAsync
     *
     * 查看仓库的Forks
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $sort 排序方式: fork的时间(newest, oldest)，star的人数(stargazers) (optional, default to newest)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoForksAsync($owner, $repo, $accessToken = null, $sort = 'newest', $page = '1', $perPage = '20')
    {
        return $this->getV5ReposOwnerRepoForksAsyncWithHttpInfo($owner, $repo, $accessToken, $sort, $page, $perPage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoForksAsyncWithHttpInfo
     *
     * 查看仓库的Forks
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $sort 排序方式: fork的时间(newest, oldest)，star的人数(stargazers) (optional, default to newest)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoForksAsyncWithHttpInfo($owner, $repo, $accessToken = null, $sort = 'newest', $page = '1', $perPage = '20')
    {
        $returnType = '\Gitee\Model\Project[]';
        $request = $this->getV5ReposOwnerRepoForksRequest($owner, $repo, $accessToken, $sort, $page, $perPage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoForks'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $sort 排序方式: fork的时间(newest, oldest)，star的人数(stargazers) (optional, default to newest)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoForksRequest($owner, $repo, $accessToken = null, $sort = 'newest', $page = '1', $perPage = '20')
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoForks'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoForks'
            );
        }
        if ($perPage !== null && $perPage > 100) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5ReposOwnerRepoForks, must be smaller than or equal to 100.');
        }
        if ($perPage !== null && $perPage < 1) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5ReposOwnerRepoForks, must be bigger than or equal to 1.');
        }


        $resourcePath = '/v5/repos/{owner}/{repo}/forks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($perPage !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($perPage);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoKeys
     *
     * 获取仓库已部署的公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\SSHKey[]
     */
    public function getV5ReposOwnerRepoKeys($owner, $repo, $accessToken = null, $page = '1', $perPage = '20')
    {
        list($response) = $this->getV5ReposOwnerRepoKeysWithHttpInfo($owner, $repo, $accessToken, $page, $perPage);
        return $response;
    }

    /**
     * Operation getV5ReposOwnerRepoKeysWithHttpInfo
     *
     * 获取仓库已部署的公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\SSHKey[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoKeysWithHttpInfo($owner, $repo, $accessToken = null, $page = '1', $perPage = '20')
    {
        $returnType = '\Gitee\Model\SSHKey[]';
        $request = $this->getV5ReposOwnerRepoKeysRequest($owner, $repo, $accessToken, $page, $perPage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\SSHKey[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoKeysAsync
     *
     * 获取仓库已部署的公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoKeysAsync($owner, $repo, $accessToken = null, $page = '1', $perPage = '20')
    {
        return $this->getV5ReposOwnerRepoKeysAsyncWithHttpInfo($owner, $repo, $accessToken, $page, $perPage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoKeysAsyncWithHttpInfo
     *
     * 获取仓库已部署的公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoKeysAsyncWithHttpInfo($owner, $repo, $accessToken = null, $page = '1', $perPage = '20')
    {
        $returnType = '\Gitee\Model\SSHKey[]';
        $request = $this->getV5ReposOwnerRepoKeysRequest($owner, $repo, $accessToken, $page, $perPage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoKeys'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoKeysRequest($owner, $repo, $accessToken = null, $page = '1', $perPage = '20')
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoKeys'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoKeys'
            );
        }
        if ($perPage !== null && $perPage > 100) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5ReposOwnerRepoKeys, must be smaller than or equal to 100.');
        }
        if ($perPage !== null && $perPage < 1) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5ReposOwnerRepoKeys, must be bigger than or equal to 1.');
        }


        $resourcePath = '/v5/repos/{owner}/{repo}/keys';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($perPage !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($perPage);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoKeysAvailable
     *
     * 获取仓库可部署的公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\SSHKeyBasic[]
     */
    public function getV5ReposOwnerRepoKeysAvailable($owner, $repo, $accessToken = null, $page = '1', $perPage = '20')
    {
        list($response) = $this->getV5ReposOwnerRepoKeysAvailableWithHttpInfo($owner, $repo, $accessToken, $page, $perPage);
        return $response;
    }

    /**
     * Operation getV5ReposOwnerRepoKeysAvailableWithHttpInfo
     *
     * 获取仓库可部署的公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\SSHKeyBasic[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoKeysAvailableWithHttpInfo($owner, $repo, $accessToken = null, $page = '1', $perPage = '20')
    {
        $returnType = '\Gitee\Model\SSHKeyBasic[]';
        $request = $this->getV5ReposOwnerRepoKeysAvailableRequest($owner, $repo, $accessToken, $page, $perPage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\SSHKeyBasic[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoKeysAvailableAsync
     *
     * 获取仓库可部署的公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoKeysAvailableAsync($owner, $repo, $accessToken = null, $page = '1', $perPage = '20')
    {
        return $this->getV5ReposOwnerRepoKeysAvailableAsyncWithHttpInfo($owner, $repo, $accessToken, $page, $perPage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoKeysAvailableAsyncWithHttpInfo
     *
     * 获取仓库可部署的公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoKeysAvailableAsyncWithHttpInfo($owner, $repo, $accessToken = null, $page = '1', $perPage = '20')
    {
        $returnType = '\Gitee\Model\SSHKeyBasic[]';
        $request = $this->getV5ReposOwnerRepoKeysAvailableRequest($owner, $repo, $accessToken, $page, $perPage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoKeysAvailable'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoKeysAvailableRequest($owner, $repo, $accessToken = null, $page = '1', $perPage = '20')
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoKeysAvailable'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoKeysAvailable'
            );
        }
        if ($perPage !== null && $perPage > 100) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5ReposOwnerRepoKeysAvailable, must be smaller than or equal to 100.');
        }
        if ($perPage !== null && $perPage < 1) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5ReposOwnerRepoKeysAvailable, must be bigger than or equal to 1.');
        }


        $resourcePath = '/v5/repos/{owner}/{repo}/keys/available';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($perPage !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($perPage);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoKeysId
     *
     * 获取仓库的单个公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 公钥 ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\SSHKey
     */
    public function getV5ReposOwnerRepoKeysId($owner, $repo, $id, $accessToken = null)
    {
        list($response) = $this->getV5ReposOwnerRepoKeysIdWithHttpInfo($owner, $repo, $id, $accessToken);
        return $response;
    }

    /**
     * Operation getV5ReposOwnerRepoKeysIdWithHttpInfo
     *
     * 获取仓库的单个公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 公钥 ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\SSHKey, HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoKeysIdWithHttpInfo($owner, $repo, $id, $accessToken = null)
    {
        $returnType = '\Gitee\Model\SSHKey';
        $request = $this->getV5ReposOwnerRepoKeysIdRequest($owner, $repo, $id, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\SSHKey',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoKeysIdAsync
     *
     * 获取仓库的单个公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 公钥 ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoKeysIdAsync($owner, $repo, $id, $accessToken = null)
    {
        return $this->getV5ReposOwnerRepoKeysIdAsyncWithHttpInfo($owner, $repo, $id, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoKeysIdAsyncWithHttpInfo
     *
     * 获取仓库的单个公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 公钥 ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoKeysIdAsyncWithHttpInfo($owner, $repo, $id, $accessToken = null)
    {
        $returnType = '\Gitee\Model\SSHKey';
        $request = $this->getV5ReposOwnerRepoKeysIdRequest($owner, $repo, $id, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoKeysId'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 公钥 ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoKeysIdRequest($owner, $repo, $id, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoKeysId'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoKeysId'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getV5ReposOwnerRepoKeysId'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/keys/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoPages
     *
     * 获取Pages信息
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getV5ReposOwnerRepoPages($owner, $repo, $accessToken = null)
    {
        $this->getV5ReposOwnerRepoPagesWithHttpInfo($owner, $repo, $accessToken);
    }

    /**
     * Operation getV5ReposOwnerRepoPagesWithHttpInfo
     *
     * 获取Pages信息
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoPagesWithHttpInfo($owner, $repo, $accessToken = null)
    {
        $returnType = '';
        $request = $this->getV5ReposOwnerRepoPagesRequest($owner, $repo, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoPagesAsync
     *
     * 获取Pages信息
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoPagesAsync($owner, $repo, $accessToken = null)
    {
        return $this->getV5ReposOwnerRepoPagesAsyncWithHttpInfo($owner, $repo, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoPagesAsyncWithHttpInfo
     *
     * 获取Pages信息
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoPagesAsyncWithHttpInfo($owner, $repo, $accessToken = null)
    {
        $returnType = '';
        $request = $this->getV5ReposOwnerRepoPagesRequest($owner, $repo, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoPages'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoPagesRequest($owner, $repo, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoPages'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoPages'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/pages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoPushConfig
     *
     * 获取仓库推送规则设置
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\ProjectPushConfig
     */
    public function getV5ReposOwnerRepoPushConfig($owner, $repo, $accessToken = null)
    {
        list($response) = $this->getV5ReposOwnerRepoPushConfigWithHttpInfo($owner, $repo, $accessToken);
        return $response;
    }

    /**
     * Operation getV5ReposOwnerRepoPushConfigWithHttpInfo
     *
     * 获取仓库推送规则设置
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\ProjectPushConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoPushConfigWithHttpInfo($owner, $repo, $accessToken = null)
    {
        $returnType = '\Gitee\Model\ProjectPushConfig';
        $request = $this->getV5ReposOwnerRepoPushConfigRequest($owner, $repo, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\ProjectPushConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoPushConfigAsync
     *
     * 获取仓库推送规则设置
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoPushConfigAsync($owner, $repo, $accessToken = null)
    {
        return $this->getV5ReposOwnerRepoPushConfigAsyncWithHttpInfo($owner, $repo, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoPushConfigAsyncWithHttpInfo
     *
     * 获取仓库推送规则设置
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoPushConfigAsyncWithHttpInfo($owner, $repo, $accessToken = null)
    {
        $returnType = '\Gitee\Model\ProjectPushConfig';
        $request = $this->getV5ReposOwnerRepoPushConfigRequest($owner, $repo, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoPushConfig'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoPushConfigRequest($owner, $repo, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoPushConfig'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoPushConfig'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/push_config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoRawPath
     *
     * 获取 raw 文件（100MB 以内）
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag 或 commit。默认: 仓库的默认分支（通常是 master） (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getV5ReposOwnerRepoRawPath($owner, $repo, $path, $accessToken = null, $ref = null)
    {
        $this->getV5ReposOwnerRepoRawPathWithHttpInfo($owner, $repo, $path, $accessToken, $ref);
    }

    /**
     * Operation getV5ReposOwnerRepoRawPathWithHttpInfo
     *
     * 获取 raw 文件（100MB 以内）
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag 或 commit。默认: 仓库的默认分支（通常是 master） (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoRawPathWithHttpInfo($owner, $repo, $path, $accessToken = null, $ref = null)
    {
        $returnType = '';
        $request = $this->getV5ReposOwnerRepoRawPathRequest($owner, $repo, $path, $accessToken, $ref);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoRawPathAsync
     *
     * 获取 raw 文件（100MB 以内）
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag 或 commit。默认: 仓库的默认分支（通常是 master） (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoRawPathAsync($owner, $repo, $path, $accessToken = null, $ref = null)
    {
        return $this->getV5ReposOwnerRepoRawPathAsyncWithHttpInfo($owner, $repo, $path, $accessToken, $ref)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoRawPathAsyncWithHttpInfo
     *
     * 获取 raw 文件（100MB 以内）
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag 或 commit。默认: 仓库的默认分支（通常是 master） (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoRawPathAsyncWithHttpInfo($owner, $repo, $path, $accessToken = null, $ref = null)
    {
        $returnType = '';
        $request = $this->getV5ReposOwnerRepoRawPathRequest($owner, $repo, $path, $accessToken, $ref);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoRawPath'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag 或 commit。默认: 仓库的默认分支（通常是 master） (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoRawPathRequest($owner, $repo, $path, $accessToken = null, $ref = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoRawPath'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoRawPath'
            );
        }
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getV5ReposOwnerRepoRawPath'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/raw/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }
        // query params
        if ($ref !== null) {
            $queryParams['ref'] = ObjectSerializer::toQueryValue($ref);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                '{' . 'path' . '}',
                ObjectSerializer::toPathValue($path),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoReadme
     *
     * 获取仓库README
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag或commit。默认: 仓库的默认分支(通常是master) (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Content
     */
    public function getV5ReposOwnerRepoReadme($owner, $repo, $accessToken = null, $ref = null)
    {
        list($response) = $this->getV5ReposOwnerRepoReadmeWithHttpInfo($owner, $repo, $accessToken, $ref);
        return $response;
    }

    /**
     * Operation getV5ReposOwnerRepoReadmeWithHttpInfo
     *
     * 获取仓库README
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag或commit。默认: 仓库的默认分支(通常是master) (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Content, HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoReadmeWithHttpInfo($owner, $repo, $accessToken = null, $ref = null)
    {
        $returnType = '\Gitee\Model\Content';
        $request = $this->getV5ReposOwnerRepoReadmeRequest($owner, $repo, $accessToken, $ref);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Content',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoReadmeAsync
     *
     * 获取仓库README
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag或commit。默认: 仓库的默认分支(通常是master) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoReadmeAsync($owner, $repo, $accessToken = null, $ref = null)
    {
        return $this->getV5ReposOwnerRepoReadmeAsyncWithHttpInfo($owner, $repo, $accessToken, $ref)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoReadmeAsyncWithHttpInfo
     *
     * 获取仓库README
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag或commit。默认: 仓库的默认分支(通常是master) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoReadmeAsyncWithHttpInfo($owner, $repo, $accessToken = null, $ref = null)
    {
        $returnType = '\Gitee\Model\Content';
        $request = $this->getV5ReposOwnerRepoReadmeRequest($owner, $repo, $accessToken, $ref);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoReadme'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag或commit。默认: 仓库的默认分支(通常是master) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoReadmeRequest($owner, $repo, $accessToken = null, $ref = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoReadme'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoReadme'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/readme';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }
        // query params
        if ($ref !== null) {
            $queryParams['ref'] = ObjectSerializer::toQueryValue($ref);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoReleases
     *
     * 获取仓库的所有Releases
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     * @param  string $direction 可选。升序/降序。不填为升序 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Release[]
     */
    public function getV5ReposOwnerRepoReleases($owner, $repo, $accessToken = null, $page = '1', $perPage = '20', $direction = null)
    {
        list($response) = $this->getV5ReposOwnerRepoReleasesWithHttpInfo($owner, $repo, $accessToken, $page, $perPage, $direction);
        return $response;
    }

    /**
     * Operation getV5ReposOwnerRepoReleasesWithHttpInfo
     *
     * 获取仓库的所有Releases
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     * @param  string $direction 可选。升序/降序。不填为升序 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Release[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoReleasesWithHttpInfo($owner, $repo, $accessToken = null, $page = '1', $perPage = '20', $direction = null)
    {
        $returnType = '\Gitee\Model\Release[]';
        $request = $this->getV5ReposOwnerRepoReleasesRequest($owner, $repo, $accessToken, $page, $perPage, $direction);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Release[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoReleasesAsync
     *
     * 获取仓库的所有Releases
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     * @param  string $direction 可选。升序/降序。不填为升序 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoReleasesAsync($owner, $repo, $accessToken = null, $page = '1', $perPage = '20', $direction = null)
    {
        return $this->getV5ReposOwnerRepoReleasesAsyncWithHttpInfo($owner, $repo, $accessToken, $page, $perPage, $direction)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoReleasesAsyncWithHttpInfo
     *
     * 获取仓库的所有Releases
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     * @param  string $direction 可选。升序/降序。不填为升序 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoReleasesAsyncWithHttpInfo($owner, $repo, $accessToken = null, $page = '1', $perPage = '20', $direction = null)
    {
        $returnType = '\Gitee\Model\Release[]';
        $request = $this->getV5ReposOwnerRepoReleasesRequest($owner, $repo, $accessToken, $page, $perPage, $direction);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoReleases'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     * @param  string $direction 可选。升序/降序。不填为升序 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoReleasesRequest($owner, $repo, $accessToken = null, $page = '1', $perPage = '20', $direction = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoReleases'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoReleases'
            );
        }
        if ($perPage !== null && $perPage > 100) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5ReposOwnerRepoReleases, must be smaller than or equal to 100.');
        }
        if ($perPage !== null && $perPage < 1) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5ReposOwnerRepoReleases, must be bigger than or equal to 1.');
        }


        $resourcePath = '/v5/repos/{owner}/{repo}/releases';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($perPage !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($perPage);
        }
        // query params
        if ($direction !== null) {
            $queryParams['direction'] = ObjectSerializer::toQueryValue($direction);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoReleasesId
     *
     * 获取仓库的单个Releases
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 发行版本的ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Release
     */
    public function getV5ReposOwnerRepoReleasesId($owner, $repo, $id, $accessToken = null)
    {
        list($response) = $this->getV5ReposOwnerRepoReleasesIdWithHttpInfo($owner, $repo, $id, $accessToken);
        return $response;
    }

    /**
     * Operation getV5ReposOwnerRepoReleasesIdWithHttpInfo
     *
     * 获取仓库的单个Releases
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 发行版本的ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Release, HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoReleasesIdWithHttpInfo($owner, $repo, $id, $accessToken = null)
    {
        $returnType = '\Gitee\Model\Release';
        $request = $this->getV5ReposOwnerRepoReleasesIdRequest($owner, $repo, $id, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Release',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoReleasesIdAsync
     *
     * 获取仓库的单个Releases
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 发行版本的ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoReleasesIdAsync($owner, $repo, $id, $accessToken = null)
    {
        return $this->getV5ReposOwnerRepoReleasesIdAsyncWithHttpInfo($owner, $repo, $id, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoReleasesIdAsyncWithHttpInfo
     *
     * 获取仓库的单个Releases
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 发行版本的ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoReleasesIdAsyncWithHttpInfo($owner, $repo, $id, $accessToken = null)
    {
        $returnType = '\Gitee\Model\Release';
        $request = $this->getV5ReposOwnerRepoReleasesIdRequest($owner, $repo, $id, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoReleasesId'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 发行版本的ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoReleasesIdRequest($owner, $repo, $id, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoReleasesId'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoReleasesId'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getV5ReposOwnerRepoReleasesId'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/releases/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoReleasesLatest
     *
     * 获取仓库的最后更新的Release
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Release
     */
    public function getV5ReposOwnerRepoReleasesLatest($owner, $repo, $accessToken = null)
    {
        list($response) = $this->getV5ReposOwnerRepoReleasesLatestWithHttpInfo($owner, $repo, $accessToken);
        return $response;
    }

    /**
     * Operation getV5ReposOwnerRepoReleasesLatestWithHttpInfo
     *
     * 获取仓库的最后更新的Release
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Release, HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoReleasesLatestWithHttpInfo($owner, $repo, $accessToken = null)
    {
        $returnType = '\Gitee\Model\Release';
        $request = $this->getV5ReposOwnerRepoReleasesLatestRequest($owner, $repo, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Release',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoReleasesLatestAsync
     *
     * 获取仓库的最后更新的Release
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoReleasesLatestAsync($owner, $repo, $accessToken = null)
    {
        return $this->getV5ReposOwnerRepoReleasesLatestAsyncWithHttpInfo($owner, $repo, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoReleasesLatestAsyncWithHttpInfo
     *
     * 获取仓库的最后更新的Release
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoReleasesLatestAsyncWithHttpInfo($owner, $repo, $accessToken = null)
    {
        $returnType = '\Gitee\Model\Release';
        $request = $this->getV5ReposOwnerRepoReleasesLatestRequest($owner, $repo, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoReleasesLatest'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoReleasesLatestRequest($owner, $repo, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoReleasesLatest'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoReleasesLatest'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/releases/latest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoReleasesReleaseIdAttachFiles
     *
     * 获取仓库下的指定 Release 的所有附件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $releaseId 发行版本的ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     * @param  string $direction 可选: 升序/降序，默认为升序 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\AttachFile[]
     */
    public function getV5ReposOwnerRepoReleasesReleaseIdAttachFiles($owner, $repo, $releaseId, $accessToken = null, $page = '1', $perPage = '20', $direction = null)
    {
        list($response) = $this->getV5ReposOwnerRepoReleasesReleaseIdAttachFilesWithHttpInfo($owner, $repo, $releaseId, $accessToken, $page, $perPage, $direction);
        return $response;
    }

    /**
     * Operation getV5ReposOwnerRepoReleasesReleaseIdAttachFilesWithHttpInfo
     *
     * 获取仓库下的指定 Release 的所有附件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $releaseId 发行版本的ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     * @param  string $direction 可选: 升序/降序，默认为升序 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\AttachFile[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoReleasesReleaseIdAttachFilesWithHttpInfo($owner, $repo, $releaseId, $accessToken = null, $page = '1', $perPage = '20', $direction = null)
    {
        $returnType = '\Gitee\Model\AttachFile[]';
        $request = $this->getV5ReposOwnerRepoReleasesReleaseIdAttachFilesRequest($owner, $repo, $releaseId, $accessToken, $page, $perPage, $direction);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\AttachFile[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAsync
     *
     * 获取仓库下的指定 Release 的所有附件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $releaseId 发行版本的ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     * @param  string $direction 可选: 升序/降序，默认为升序 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAsync($owner, $repo, $releaseId, $accessToken = null, $page = '1', $perPage = '20', $direction = null)
    {
        return $this->getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAsyncWithHttpInfo($owner, $repo, $releaseId, $accessToken, $page, $perPage, $direction)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAsyncWithHttpInfo
     *
     * 获取仓库下的指定 Release 的所有附件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $releaseId 发行版本的ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     * @param  string $direction 可选: 升序/降序，默认为升序 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAsyncWithHttpInfo($owner, $repo, $releaseId, $accessToken = null, $page = '1', $perPage = '20', $direction = null)
    {
        $returnType = '\Gitee\Model\AttachFile[]';
        $request = $this->getV5ReposOwnerRepoReleasesReleaseIdAttachFilesRequest($owner, $repo, $releaseId, $accessToken, $page, $perPage, $direction);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoReleasesReleaseIdAttachFiles'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $releaseId 发行版本的ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     * @param  string $direction 可选: 升序/降序，默认为升序 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoReleasesReleaseIdAttachFilesRequest($owner, $repo, $releaseId, $accessToken = null, $page = '1', $perPage = '20', $direction = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoReleasesReleaseIdAttachFiles'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoReleasesReleaseIdAttachFiles'
            );
        }
        // verify the required parameter 'releaseId' is set
        if ($releaseId === null || (is_array($releaseId) && count($releaseId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $releaseId when calling getV5ReposOwnerRepoReleasesReleaseIdAttachFiles'
            );
        }
        if ($perPage !== null && $perPage > 100) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5ReposOwnerRepoReleasesReleaseIdAttachFiles, must be smaller than or equal to 100.');
        }
        if ($perPage !== null && $perPage < 1) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5ReposOwnerRepoReleasesReleaseIdAttachFiles, must be bigger than or equal to 1.');
        }


        $resourcePath = '/v5/repos/{owner}/{repo}/releases/{release_id}/attach_files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($perPage !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($perPage);
        }
        // query params
        if ($direction !== null) {
            $queryParams['direction'] = ObjectSerializer::toQueryValue($direction);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($releaseId !== null) {
            $resourcePath = str_replace(
                '{' . 'release_id' . '}',
                ObjectSerializer::toPathValue($releaseId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileId
     *
     * 获取仓库下指定 Release 的单个附件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $releaseId 发行版本的ID (required)
     * @param  int $attachFileId 发行版本下的附件ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\AttachFile
     */
    public function getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileId($owner, $repo, $releaseId, $attachFileId, $accessToken = null)
    {
        list($response) = $this->getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdWithHttpInfo($owner, $repo, $releaseId, $attachFileId, $accessToken);
        return $response;
    }

    /**
     * Operation getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdWithHttpInfo
     *
     * 获取仓库下指定 Release 的单个附件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $releaseId 发行版本的ID (required)
     * @param  int $attachFileId 发行版本下的附件ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\AttachFile, HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdWithHttpInfo($owner, $repo, $releaseId, $attachFileId, $accessToken = null)
    {
        $returnType = '\Gitee\Model\AttachFile';
        $request = $this->getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdRequest($owner, $repo, $releaseId, $attachFileId, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\AttachFile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdAsync
     *
     * 获取仓库下指定 Release 的单个附件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $releaseId 发行版本的ID (required)
     * @param  int $attachFileId 发行版本下的附件ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdAsync($owner, $repo, $releaseId, $attachFileId, $accessToken = null)
    {
        return $this->getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdAsyncWithHttpInfo($owner, $repo, $releaseId, $attachFileId, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdAsyncWithHttpInfo
     *
     * 获取仓库下指定 Release 的单个附件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $releaseId 发行版本的ID (required)
     * @param  int $attachFileId 发行版本下的附件ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdAsyncWithHttpInfo($owner, $repo, $releaseId, $attachFileId, $accessToken = null)
    {
        $returnType = '\Gitee\Model\AttachFile';
        $request = $this->getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdRequest($owner, $repo, $releaseId, $attachFileId, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileId'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $releaseId 发行版本的ID (required)
     * @param  int $attachFileId 发行版本下的附件ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdRequest($owner, $repo, $releaseId, $attachFileId, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileId'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileId'
            );
        }
        // verify the required parameter 'releaseId' is set
        if ($releaseId === null || (is_array($releaseId) && count($releaseId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $releaseId when calling getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileId'
            );
        }
        // verify the required parameter 'attachFileId' is set
        if ($attachFileId === null || (is_array($attachFileId) && count($attachFileId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachFileId when calling getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileId'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/releases/{release_id}/attach_files/{attach_file_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($releaseId !== null) {
            $resourcePath = str_replace(
                '{' . 'release_id' . '}',
                ObjectSerializer::toPathValue($releaseId),
                $resourcePath
            );
        }
        // path params
        if ($attachFileId !== null) {
            $resourcePath = str_replace(
                '{' . 'attach_file_id' . '}',
                ObjectSerializer::toPathValue($attachFileId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdDownload
     *
     * 下载指定 Release 的单个附件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $releaseId 发行版本的ID (required)
     * @param  int $attachFileId 发行版本下的附件ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdDownload($owner, $repo, $releaseId, $attachFileId, $accessToken = null)
    {
        $this->getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdDownloadWithHttpInfo($owner, $repo, $releaseId, $attachFileId, $accessToken);
    }

    /**
     * Operation getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdDownloadWithHttpInfo
     *
     * 下载指定 Release 的单个附件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $releaseId 发行版本的ID (required)
     * @param  int $attachFileId 发行版本下的附件ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdDownloadWithHttpInfo($owner, $repo, $releaseId, $attachFileId, $accessToken = null)
    {
        $returnType = '';
        $request = $this->getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdDownloadRequest($owner, $repo, $releaseId, $attachFileId, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdDownloadAsync
     *
     * 下载指定 Release 的单个附件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $releaseId 发行版本的ID (required)
     * @param  int $attachFileId 发行版本下的附件ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdDownloadAsync($owner, $repo, $releaseId, $attachFileId, $accessToken = null)
    {
        return $this->getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdDownloadAsyncWithHttpInfo($owner, $repo, $releaseId, $attachFileId, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdDownloadAsyncWithHttpInfo
     *
     * 下载指定 Release 的单个附件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $releaseId 发行版本的ID (required)
     * @param  int $attachFileId 发行版本下的附件ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdDownloadAsyncWithHttpInfo($owner, $repo, $releaseId, $attachFileId, $accessToken = null)
    {
        $returnType = '';
        $request = $this->getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdDownloadRequest($owner, $repo, $releaseId, $attachFileId, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdDownload'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $releaseId 发行版本的ID (required)
     * @param  int $attachFileId 发行版本下的附件ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdDownloadRequest($owner, $repo, $releaseId, $attachFileId, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdDownload'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdDownload'
            );
        }
        // verify the required parameter 'releaseId' is set
        if ($releaseId === null || (is_array($releaseId) && count($releaseId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $releaseId when calling getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdDownload'
            );
        }
        // verify the required parameter 'attachFileId' is set
        if ($attachFileId === null || (is_array($attachFileId) && count($attachFileId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachFileId when calling getV5ReposOwnerRepoReleasesReleaseIdAttachFilesAttachFileIdDownload'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/releases/{release_id}/attach_files/{attach_file_id}/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($releaseId !== null) {
            $resourcePath = str_replace(
                '{' . 'release_id' . '}',
                ObjectSerializer::toPathValue($releaseId),
                $resourcePath
            );
        }
        // path params
        if ($attachFileId !== null) {
            $resourcePath = str_replace(
                '{' . 'attach_file_id' . '}',
                ObjectSerializer::toPathValue($attachFileId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoReleasesTagsTag
     *
     * 根据Tag名称获取仓库的Release
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $tag Tag 名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Release
     */
    public function getV5ReposOwnerRepoReleasesTagsTag($owner, $repo, $tag, $accessToken = null)
    {
        list($response) = $this->getV5ReposOwnerRepoReleasesTagsTagWithHttpInfo($owner, $repo, $tag, $accessToken);
        return $response;
    }

    /**
     * Operation getV5ReposOwnerRepoReleasesTagsTagWithHttpInfo
     *
     * 根据Tag名称获取仓库的Release
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $tag Tag 名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Release, HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoReleasesTagsTagWithHttpInfo($owner, $repo, $tag, $accessToken = null)
    {
        $returnType = '\Gitee\Model\Release';
        $request = $this->getV5ReposOwnerRepoReleasesTagsTagRequest($owner, $repo, $tag, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Release',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoReleasesTagsTagAsync
     *
     * 根据Tag名称获取仓库的Release
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $tag Tag 名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoReleasesTagsTagAsync($owner, $repo, $tag, $accessToken = null)
    {
        return $this->getV5ReposOwnerRepoReleasesTagsTagAsyncWithHttpInfo($owner, $repo, $tag, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoReleasesTagsTagAsyncWithHttpInfo
     *
     * 根据Tag名称获取仓库的Release
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $tag Tag 名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoReleasesTagsTagAsyncWithHttpInfo($owner, $repo, $tag, $accessToken = null)
    {
        $returnType = '\Gitee\Model\Release';
        $request = $this->getV5ReposOwnerRepoReleasesTagsTagRequest($owner, $repo, $tag, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoReleasesTagsTag'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $tag Tag 名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoReleasesTagsTagRequest($owner, $repo, $tag, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoReleasesTagsTag'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoReleasesTagsTag'
            );
        }
        // verify the required parameter 'tag' is set
        if ($tag === null || (is_array($tag) && count($tag) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tag when calling getV5ReposOwnerRepoReleasesTagsTag'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/releases/tags/{tag}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($tag !== null) {
            $resourcePath = str_replace(
                '{' . 'tag' . '}',
                ObjectSerializer::toPathValue($tag),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoTags
     *
     * 列出仓库所有的 tags
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $sort 排序字段 (optional, default to name)
     * @param  string $direction 排序方向 (optional, default to asc)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Tag[]
     */
    public function getV5ReposOwnerRepoTags($owner, $repo, $accessToken = null, $sort = 'name', $direction = 'asc', $page = '1', $perPage = null)
    {
        list($response) = $this->getV5ReposOwnerRepoTagsWithHttpInfo($owner, $repo, $accessToken, $sort, $direction, $page, $perPage);
        return $response;
    }

    /**
     * Operation getV5ReposOwnerRepoTagsWithHttpInfo
     *
     * 列出仓库所有的 tags
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $sort 排序字段 (optional, default to name)
     * @param  string $direction 排序方向 (optional, default to asc)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Tag[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoTagsWithHttpInfo($owner, $repo, $accessToken = null, $sort = 'name', $direction = 'asc', $page = '1', $perPage = null)
    {
        $returnType = '\Gitee\Model\Tag[]';
        $request = $this->getV5ReposOwnerRepoTagsRequest($owner, $repo, $accessToken, $sort, $direction, $page, $perPage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Tag[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoTagsAsync
     *
     * 列出仓库所有的 tags
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $sort 排序字段 (optional, default to name)
     * @param  string $direction 排序方向 (optional, default to asc)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoTagsAsync($owner, $repo, $accessToken = null, $sort = 'name', $direction = 'asc', $page = '1', $perPage = null)
    {
        return $this->getV5ReposOwnerRepoTagsAsyncWithHttpInfo($owner, $repo, $accessToken, $sort, $direction, $page, $perPage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoTagsAsyncWithHttpInfo
     *
     * 列出仓库所有的 tags
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $sort 排序字段 (optional, default to name)
     * @param  string $direction 排序方向 (optional, default to asc)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoTagsAsyncWithHttpInfo($owner, $repo, $accessToken = null, $sort = 'name', $direction = 'asc', $page = '1', $perPage = null)
    {
        $returnType = '\Gitee\Model\Tag[]';
        $request = $this->getV5ReposOwnerRepoTagsRequest($owner, $repo, $accessToken, $sort, $direction, $page, $perPage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoTags'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $sort 排序字段 (optional, default to name)
     * @param  string $direction 排序方向 (optional, default to asc)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoTagsRequest($owner, $repo, $accessToken = null, $sort = 'name', $direction = 'asc', $page = '1', $perPage = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoTags'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoTags'
            );
        }
        if ($perPage !== null && $perPage > 100) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5ReposOwnerRepoTags, must be smaller than or equal to 100.');
        }
        if ($perPage !== null && $perPage < 1) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5ReposOwnerRepoTags, must be bigger than or equal to 1.');
        }


        $resourcePath = '/v5/repos/{owner}/{repo}/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($direction !== null) {
            $queryParams['direction'] = ObjectSerializer::toQueryValue($direction);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($perPage !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($perPage);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoTarball
     *
     * 下载仓库 tar.gz
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag或commit。默认: 仓库的默认分支(通常是master) (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getV5ReposOwnerRepoTarball($owner, $repo, $accessToken = null, $ref = null)
    {
        $this->getV5ReposOwnerRepoTarballWithHttpInfo($owner, $repo, $accessToken, $ref);
    }

    /**
     * Operation getV5ReposOwnerRepoTarballWithHttpInfo
     *
     * 下载仓库 tar.gz
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag或commit。默认: 仓库的默认分支(通常是master) (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoTarballWithHttpInfo($owner, $repo, $accessToken = null, $ref = null)
    {
        $returnType = '';
        $request = $this->getV5ReposOwnerRepoTarballRequest($owner, $repo, $accessToken, $ref);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoTarballAsync
     *
     * 下载仓库 tar.gz
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag或commit。默认: 仓库的默认分支(通常是master) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoTarballAsync($owner, $repo, $accessToken = null, $ref = null)
    {
        return $this->getV5ReposOwnerRepoTarballAsyncWithHttpInfo($owner, $repo, $accessToken, $ref)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoTarballAsyncWithHttpInfo
     *
     * 下载仓库 tar.gz
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag或commit。默认: 仓库的默认分支(通常是master) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoTarballAsyncWithHttpInfo($owner, $repo, $accessToken = null, $ref = null)
    {
        $returnType = '';
        $request = $this->getV5ReposOwnerRepoTarballRequest($owner, $repo, $accessToken, $ref);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoTarball'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag或commit。默认: 仓库的默认分支(通常是master) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoTarballRequest($owner, $repo, $accessToken = null, $ref = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoTarball'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoTarball'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/tarball';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }
        // query params
        if ($ref !== null) {
            $queryParams['ref'] = ObjectSerializer::toQueryValue($ref);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/gzip']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/gzip'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5ReposOwnerRepoZipball
     *
     * 下载仓库 zip
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag或commit。默认: 仓库的默认分支(通常是master) (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getV5ReposOwnerRepoZipball($owner, $repo, $accessToken = null, $ref = null)
    {
        $this->getV5ReposOwnerRepoZipballWithHttpInfo($owner, $repo, $accessToken, $ref);
    }

    /**
     * Operation getV5ReposOwnerRepoZipballWithHttpInfo
     *
     * 下载仓库 zip
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag或commit。默认: 仓库的默认分支(通常是master) (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5ReposOwnerRepoZipballWithHttpInfo($owner, $repo, $accessToken = null, $ref = null)
    {
        $returnType = '';
        $request = $this->getV5ReposOwnerRepoZipballRequest($owner, $repo, $accessToken, $ref);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getV5ReposOwnerRepoZipballAsync
     *
     * 下载仓库 zip
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag或commit。默认: 仓库的默认分支(通常是master) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoZipballAsync($owner, $repo, $accessToken = null, $ref = null)
    {
        return $this->getV5ReposOwnerRepoZipballAsyncWithHttpInfo($owner, $repo, $accessToken, $ref)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5ReposOwnerRepoZipballAsyncWithHttpInfo
     *
     * 下载仓库 zip
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag或commit。默认: 仓库的默认分支(通常是master) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5ReposOwnerRepoZipballAsyncWithHttpInfo($owner, $repo, $accessToken = null, $ref = null)
    {
        $returnType = '';
        $request = $this->getV5ReposOwnerRepoZipballRequest($owner, $repo, $accessToken, $ref);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5ReposOwnerRepoZipball'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $ref 分支、tag或commit。默认: 仓库的默认分支(通常是master) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5ReposOwnerRepoZipballRequest($owner, $repo, $accessToken = null, $ref = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling getV5ReposOwnerRepoZipball'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling getV5ReposOwnerRepoZipball'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/zipball';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }
        // query params
        if ($ref !== null) {
            $queryParams['ref'] = ObjectSerializer::toQueryValue($ref);
        }

        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/zip']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/zip'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5UserRepos
     *
     * 列出授权用户的所有仓库
     *
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $visibility 公开(public)、私有(private)或者所有(all)，默认: 所有(all) (optional)
     * @param  string $affiliation owner(授权用户拥有的仓库)、collaborator(授权用户为仓库成员)、organization_member(授权用户为仓库所在组织并有访问仓库权限)、enterprise_member(授权用户所在企业并有访问仓库权限)、admin(所有有权限的，包括所管理的组织中所有仓库、所管理的企业的所有仓库)。                    可以用逗号分隔符组合。如: owner, organization_member 或 owner, collaborator, organization_member (optional)
     * @param  string $type 筛选用户仓库: 其创建(owner)、个人(personal)、其为成员(member)、公开(public)、私有(private)，不能与 visibility 或 affiliation 参数一并使用，否则会报 422 错误 (optional)
     * @param  string $sort 排序方式: 创建时间(created)，更新时间(updated)，最后推送时间(pushed)，仓库所属与名称(full_name)。默认: full_name (optional, default to full_name)
     * @param  string $direction 如果sort参数为full_name，用升序(asc)。否则降序(desc) (optional)
     * @param  string $q 搜索关键字 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Project[]
     */
    public function getV5UserRepos($accessToken = null, $visibility = null, $affiliation = null, $type = null, $sort = 'full_name', $direction = null, $q = null, $page = '1', $perPage = '20')
    {
        list($response) = $this->getV5UserReposWithHttpInfo($accessToken, $visibility, $affiliation, $type, $sort, $direction, $q, $page, $perPage);
        return $response;
    }

    /**
     * Operation getV5UserReposWithHttpInfo
     *
     * 列出授权用户的所有仓库
     *
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $visibility 公开(public)、私有(private)或者所有(all)，默认: 所有(all) (optional)
     * @param  string $affiliation owner(授权用户拥有的仓库)、collaborator(授权用户为仓库成员)、organization_member(授权用户为仓库所在组织并有访问仓库权限)、enterprise_member(授权用户所在企业并有访问仓库权限)、admin(所有有权限的，包括所管理的组织中所有仓库、所管理的企业的所有仓库)。                    可以用逗号分隔符组合。如: owner, organization_member 或 owner, collaborator, organization_member (optional)
     * @param  string $type 筛选用户仓库: 其创建(owner)、个人(personal)、其为成员(member)、公开(public)、私有(private)，不能与 visibility 或 affiliation 参数一并使用，否则会报 422 错误 (optional)
     * @param  string $sort 排序方式: 创建时间(created)，更新时间(updated)，最后推送时间(pushed)，仓库所属与名称(full_name)。默认: full_name (optional, default to full_name)
     * @param  string $direction 如果sort参数为full_name，用升序(asc)。否则降序(desc) (optional)
     * @param  string $q 搜索关键字 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Project[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5UserReposWithHttpInfo($accessToken = null, $visibility = null, $affiliation = null, $type = null, $sort = 'full_name', $direction = null, $q = null, $page = '1', $perPage = '20')
    {
        $returnType = '\Gitee\Model\Project[]';
        $request = $this->getV5UserReposRequest($accessToken, $visibility, $affiliation, $type, $sort, $direction, $q, $page, $perPage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Project[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5UserReposAsync
     *
     * 列出授权用户的所有仓库
     *
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $visibility 公开(public)、私有(private)或者所有(all)，默认: 所有(all) (optional)
     * @param  string $affiliation owner(授权用户拥有的仓库)、collaborator(授权用户为仓库成员)、organization_member(授权用户为仓库所在组织并有访问仓库权限)、enterprise_member(授权用户所在企业并有访问仓库权限)、admin(所有有权限的，包括所管理的组织中所有仓库、所管理的企业的所有仓库)。                    可以用逗号分隔符组合。如: owner, organization_member 或 owner, collaborator, organization_member (optional)
     * @param  string $type 筛选用户仓库: 其创建(owner)、个人(personal)、其为成员(member)、公开(public)、私有(private)，不能与 visibility 或 affiliation 参数一并使用，否则会报 422 错误 (optional)
     * @param  string $sort 排序方式: 创建时间(created)，更新时间(updated)，最后推送时间(pushed)，仓库所属与名称(full_name)。默认: full_name (optional, default to full_name)
     * @param  string $direction 如果sort参数为full_name，用升序(asc)。否则降序(desc) (optional)
     * @param  string $q 搜索关键字 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5UserReposAsync($accessToken = null, $visibility = null, $affiliation = null, $type = null, $sort = 'full_name', $direction = null, $q = null, $page = '1', $perPage = '20')
    {
        return $this->getV5UserReposAsyncWithHttpInfo($accessToken, $visibility, $affiliation, $type, $sort, $direction, $q, $page, $perPage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5UserReposAsyncWithHttpInfo
     *
     * 列出授权用户的所有仓库
     *
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $visibility 公开(public)、私有(private)或者所有(all)，默认: 所有(all) (optional)
     * @param  string $affiliation owner(授权用户拥有的仓库)、collaborator(授权用户为仓库成员)、organization_member(授权用户为仓库所在组织并有访问仓库权限)、enterprise_member(授权用户所在企业并有访问仓库权限)、admin(所有有权限的，包括所管理的组织中所有仓库、所管理的企业的所有仓库)。                    可以用逗号分隔符组合。如: owner, organization_member 或 owner, collaborator, organization_member (optional)
     * @param  string $type 筛选用户仓库: 其创建(owner)、个人(personal)、其为成员(member)、公开(public)、私有(private)，不能与 visibility 或 affiliation 参数一并使用，否则会报 422 错误 (optional)
     * @param  string $sort 排序方式: 创建时间(created)，更新时间(updated)，最后推送时间(pushed)，仓库所属与名称(full_name)。默认: full_name (optional, default to full_name)
     * @param  string $direction 如果sort参数为full_name，用升序(asc)。否则降序(desc) (optional)
     * @param  string $q 搜索关键字 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5UserReposAsyncWithHttpInfo($accessToken = null, $visibility = null, $affiliation = null, $type = null, $sort = 'full_name', $direction = null, $q = null, $page = '1', $perPage = '20')
    {
        $returnType = '\Gitee\Model\Project[]';
        $request = $this->getV5UserReposRequest($accessToken, $visibility, $affiliation, $type, $sort, $direction, $q, $page, $perPage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5UserRepos'
     *
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $visibility 公开(public)、私有(private)或者所有(all)，默认: 所有(all) (optional)
     * @param  string $affiliation owner(授权用户拥有的仓库)、collaborator(授权用户为仓库成员)、organization_member(授权用户为仓库所在组织并有访问仓库权限)、enterprise_member(授权用户所在企业并有访问仓库权限)、admin(所有有权限的，包括所管理的组织中所有仓库、所管理的企业的所有仓库)。                    可以用逗号分隔符组合。如: owner, organization_member 或 owner, collaborator, organization_member (optional)
     * @param  string $type 筛选用户仓库: 其创建(owner)、个人(personal)、其为成员(member)、公开(public)、私有(private)，不能与 visibility 或 affiliation 参数一并使用，否则会报 422 错误 (optional)
     * @param  string $sort 排序方式: 创建时间(created)，更新时间(updated)，最后推送时间(pushed)，仓库所属与名称(full_name)。默认: full_name (optional, default to full_name)
     * @param  string $direction 如果sort参数为full_name，用升序(asc)。否则降序(desc) (optional)
     * @param  string $q 搜索关键字 (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5UserReposRequest($accessToken = null, $visibility = null, $affiliation = null, $type = null, $sort = 'full_name', $direction = null, $q = null, $page = '1', $perPage = '20')
    {
        if ($perPage !== null && $perPage > 100) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5UserRepos, must be smaller than or equal to 100.');
        }
        if ($perPage !== null && $perPage < 1) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5UserRepos, must be bigger than or equal to 1.');
        }


        $resourcePath = '/v5/user/repos';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }
        // query params
        if ($visibility !== null) {
            $queryParams['visibility'] = ObjectSerializer::toQueryValue($visibility);
        }
        // query params
        if ($affiliation !== null) {
            $queryParams['affiliation'] = ObjectSerializer::toQueryValue($affiliation);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($direction !== null) {
            $queryParams['direction'] = ObjectSerializer::toQueryValue($direction);
        }
        // query params
        if ($q !== null) {
            $queryParams['q'] = ObjectSerializer::toQueryValue($q);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($perPage !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($perPage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV5UsersUsernameRepos
     *
     * 获取某个用户的公开仓库
     *
     * @param  string $username 用户名(username/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $type 用户创建的仓库(owner)，用户个人仓库(personal)，用户为仓库成员(member)，所有(all)。默认: 所有(all) (optional, default to all)
     * @param  string $sort 排序方式: 创建时间(created)，更新时间(updated)，最后推送时间(pushed)，仓库所属与名称(full_name)。默认: full_name (optional, default to full_name)
     * @param  string $direction 如果sort参数为full_name，用升序(asc)。否则降序(desc) (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Project[]
     */
    public function getV5UsersUsernameRepos($username, $accessToken = null, $type = 'all', $sort = 'full_name', $direction = null, $page = '1', $perPage = '20')
    {
        list($response) = $this->getV5UsersUsernameReposWithHttpInfo($username, $accessToken, $type, $sort, $direction, $page, $perPage);
        return $response;
    }

    /**
     * Operation getV5UsersUsernameReposWithHttpInfo
     *
     * 获取某个用户的公开仓库
     *
     * @param  string $username 用户名(username/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $type 用户创建的仓库(owner)，用户个人仓库(personal)，用户为仓库成员(member)，所有(all)。默认: 所有(all) (optional, default to all)
     * @param  string $sort 排序方式: 创建时间(created)，更新时间(updated)，最后推送时间(pushed)，仓库所属与名称(full_name)。默认: full_name (optional, default to full_name)
     * @param  string $direction 如果sort参数为full_name，用升序(asc)。否则降序(desc) (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Project[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getV5UsersUsernameReposWithHttpInfo($username, $accessToken = null, $type = 'all', $sort = 'full_name', $direction = null, $page = '1', $perPage = '20')
    {
        $returnType = '\Gitee\Model\Project[]';
        $request = $this->getV5UsersUsernameReposRequest($username, $accessToken, $type, $sort, $direction, $page, $perPage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Project[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getV5UsersUsernameReposAsync
     *
     * 获取某个用户的公开仓库
     *
     * @param  string $username 用户名(username/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $type 用户创建的仓库(owner)，用户个人仓库(personal)，用户为仓库成员(member)，所有(all)。默认: 所有(all) (optional, default to all)
     * @param  string $sort 排序方式: 创建时间(created)，更新时间(updated)，最后推送时间(pushed)，仓库所属与名称(full_name)。默认: full_name (optional, default to full_name)
     * @param  string $direction 如果sort参数为full_name，用升序(asc)。否则降序(desc) (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5UsersUsernameReposAsync($username, $accessToken = null, $type = 'all', $sort = 'full_name', $direction = null, $page = '1', $perPage = '20')
    {
        return $this->getV5UsersUsernameReposAsyncWithHttpInfo($username, $accessToken, $type, $sort, $direction, $page, $perPage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV5UsersUsernameReposAsyncWithHttpInfo
     *
     * 获取某个用户的公开仓库
     *
     * @param  string $username 用户名(username/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $type 用户创建的仓库(owner)，用户个人仓库(personal)，用户为仓库成员(member)，所有(all)。默认: 所有(all) (optional, default to all)
     * @param  string $sort 排序方式: 创建时间(created)，更新时间(updated)，最后推送时间(pushed)，仓库所属与名称(full_name)。默认: full_name (optional, default to full_name)
     * @param  string $direction 如果sort参数为full_name，用升序(asc)。否则降序(desc) (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV5UsersUsernameReposAsyncWithHttpInfo($username, $accessToken = null, $type = 'all', $sort = 'full_name', $direction = null, $page = '1', $perPage = '20')
    {
        $returnType = '\Gitee\Model\Project[]';
        $request = $this->getV5UsersUsernameReposRequest($username, $accessToken, $type, $sort, $direction, $page, $perPage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV5UsersUsernameRepos'
     *
     * @param  string $username 用户名(username/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $type 用户创建的仓库(owner)，用户个人仓库(personal)，用户为仓库成员(member)，所有(all)。默认: 所有(all) (optional, default to all)
     * @param  string $sort 排序方式: 创建时间(created)，更新时间(updated)，最后推送时间(pushed)，仓库所属与名称(full_name)。默认: full_name (optional, default to full_name)
     * @param  string $direction 如果sort参数为full_name，用升序(asc)。否则降序(desc) (optional)
     * @param  int $page 当前的页码 (optional, default to 1)
     * @param  int $perPage 每页的数量，最大为 100 (optional, default to 20)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV5UsersUsernameReposRequest($username, $accessToken = null, $type = 'all', $sort = 'full_name', $direction = null, $page = '1', $perPage = '20')
    {
        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling getV5UsersUsernameRepos'
            );
        }
        if ($perPage !== null && $perPage > 100) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5UsersUsernameRepos, must be smaller than or equal to 100.');
        }
        if ($perPage !== null && $perPage < 1) {
            throw new \InvalidArgumentException('invalid value for "$perPage" when calling RepositoriesApi.getV5UsersUsernameRepos, must be bigger than or equal to 1.');
        }


        $resourcePath = '/v5/users/{username}/repos';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accessToken !== null) {
            $queryParams['access_token'] = ObjectSerializer::toQueryValue($accessToken);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($direction !== null) {
            $queryParams['direction'] = ObjectSerializer::toQueryValue($direction);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($perPage !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($perPage);
        }

        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchV5ReposOwnerRepo
     *
     * 更新仓库设置
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $name 仓库名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $description 仓库描述 (optional)
     * @param  string $homepage 主页(eg: https://gitee.com) (optional)
     * @param  bool $hasIssues 允许提Issue与否。默认: 允许(true) (optional, default to true)
     * @param  bool $hasWiki 提供Wiki与否。默认: 提供(true) (optional, default to true)
     * @param  bool $canComment 允许用户对仓库进行评论。默认： 允许(true) (optional, default to true)
     * @param  bool $issueComment 允许对“关闭”状态的 Issue 进行评论。默认: 不允许(false) (optional)
     * @param  bool $securityHoleEnabled 这个Issue涉及到安全/隐私问题，提交后不公开此Issue（可见范围：仓库成员, 企业成员） (optional)
     * @param  bool $private 仓库公开或私有。 (optional)
     * @param  string $path 更新仓库路径 (optional)
     * @param  string $defaultBranch 更新默认分支 (optional)
     * @param  bool $pullRequestsEnabled 接受 pull request，协作开发 (optional)
     * @param  bool $onlineEditEnabled 是否允许仓库文件在线编辑 (optional)
     * @param  bool $lightweightPrEnabled 是否接受轻量级 pull request (optional)
     * @param  bool $mergeEnabled 是否开启 merge 合并方式, 默认为开启 (optional)
     * @param  bool $squashEnabled 是否开启 squash 合并方式, 默认为开启 (optional)
     * @param  bool $rebaseEnabled 是否开启 rebase 合并方式, 默认为开启 (optional)
     * @param  string $defaultMergeMethod 选择默认合并 Pull Request 的方式,分别为 merge squash rebase (optional)
     * @param  string $issueTemplateSource Issue 模版来源 project: 使用仓库 Issue Template 作为模版； enterprise: 使用企业工作项作为模版 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Project
     */
    public function patchV5ReposOwnerRepo($owner, $repo, $name, $accessToken = null, $description = null, $homepage = null, $hasIssues = 'true', $hasWiki = 'true', $canComment = 'true', $issueComment = null, $securityHoleEnabled = null, $private = null, $path = null, $defaultBranch = null, $pullRequestsEnabled = null, $onlineEditEnabled = null, $lightweightPrEnabled = null, $mergeEnabled = null, $squashEnabled = null, $rebaseEnabled = null, $defaultMergeMethod = null, $issueTemplateSource = null)
    {
        list($response) = $this->patchV5ReposOwnerRepoWithHttpInfo($owner, $repo, $name, $accessToken, $description, $homepage, $hasIssues, $hasWiki, $canComment, $issueComment, $securityHoleEnabled, $private, $path, $defaultBranch, $pullRequestsEnabled, $onlineEditEnabled, $lightweightPrEnabled, $mergeEnabled, $squashEnabled, $rebaseEnabled, $defaultMergeMethod, $issueTemplateSource);
        return $response;
    }

    /**
     * Operation patchV5ReposOwnerRepoWithHttpInfo
     *
     * 更新仓库设置
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $name 仓库名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $description 仓库描述 (optional)
     * @param  string $homepage 主页(eg: https://gitee.com) (optional)
     * @param  bool $hasIssues 允许提Issue与否。默认: 允许(true) (optional, default to true)
     * @param  bool $hasWiki 提供Wiki与否。默认: 提供(true) (optional, default to true)
     * @param  bool $canComment 允许用户对仓库进行评论。默认： 允许(true) (optional, default to true)
     * @param  bool $issueComment 允许对“关闭”状态的 Issue 进行评论。默认: 不允许(false) (optional)
     * @param  bool $securityHoleEnabled 这个Issue涉及到安全/隐私问题，提交后不公开此Issue（可见范围：仓库成员, 企业成员） (optional)
     * @param  bool $private 仓库公开或私有。 (optional)
     * @param  string $path 更新仓库路径 (optional)
     * @param  string $defaultBranch 更新默认分支 (optional)
     * @param  bool $pullRequestsEnabled 接受 pull request，协作开发 (optional)
     * @param  bool $onlineEditEnabled 是否允许仓库文件在线编辑 (optional)
     * @param  bool $lightweightPrEnabled 是否接受轻量级 pull request (optional)
     * @param  bool $mergeEnabled 是否开启 merge 合并方式, 默认为开启 (optional)
     * @param  bool $squashEnabled 是否开启 squash 合并方式, 默认为开启 (optional)
     * @param  bool $rebaseEnabled 是否开启 rebase 合并方式, 默认为开启 (optional)
     * @param  string $defaultMergeMethod 选择默认合并 Pull Request 的方式,分别为 merge squash rebase (optional)
     * @param  string $issueTemplateSource Issue 模版来源 project: 使用仓库 Issue Template 作为模版； enterprise: 使用企业工作项作为模版 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Project, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchV5ReposOwnerRepoWithHttpInfo($owner, $repo, $name, $accessToken = null, $description = null, $homepage = null, $hasIssues = 'true', $hasWiki = 'true', $canComment = 'true', $issueComment = null, $securityHoleEnabled = null, $private = null, $path = null, $defaultBranch = null, $pullRequestsEnabled = null, $onlineEditEnabled = null, $lightweightPrEnabled = null, $mergeEnabled = null, $squashEnabled = null, $rebaseEnabled = null, $defaultMergeMethod = null, $issueTemplateSource = null)
    {
        $returnType = '\Gitee\Model\Project';
        $request = $this->patchV5ReposOwnerRepoRequest($owner, $repo, $name, $accessToken, $description, $homepage, $hasIssues, $hasWiki, $canComment, $issueComment, $securityHoleEnabled, $private, $path, $defaultBranch, $pullRequestsEnabled, $onlineEditEnabled, $lightweightPrEnabled, $mergeEnabled, $squashEnabled, $rebaseEnabled, $defaultMergeMethod, $issueTemplateSource);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Project',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchV5ReposOwnerRepoAsync
     *
     * 更新仓库设置
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $name 仓库名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $description 仓库描述 (optional)
     * @param  string $homepage 主页(eg: https://gitee.com) (optional)
     * @param  bool $hasIssues 允许提Issue与否。默认: 允许(true) (optional, default to true)
     * @param  bool $hasWiki 提供Wiki与否。默认: 提供(true) (optional, default to true)
     * @param  bool $canComment 允许用户对仓库进行评论。默认： 允许(true) (optional, default to true)
     * @param  bool $issueComment 允许对“关闭”状态的 Issue 进行评论。默认: 不允许(false) (optional)
     * @param  bool $securityHoleEnabled 这个Issue涉及到安全/隐私问题，提交后不公开此Issue（可见范围：仓库成员, 企业成员） (optional)
     * @param  bool $private 仓库公开或私有。 (optional)
     * @param  string $path 更新仓库路径 (optional)
     * @param  string $defaultBranch 更新默认分支 (optional)
     * @param  bool $pullRequestsEnabled 接受 pull request，协作开发 (optional)
     * @param  bool $onlineEditEnabled 是否允许仓库文件在线编辑 (optional)
     * @param  bool $lightweightPrEnabled 是否接受轻量级 pull request (optional)
     * @param  bool $mergeEnabled 是否开启 merge 合并方式, 默认为开启 (optional)
     * @param  bool $squashEnabled 是否开启 squash 合并方式, 默认为开启 (optional)
     * @param  bool $rebaseEnabled 是否开启 rebase 合并方式, 默认为开启 (optional)
     * @param  string $defaultMergeMethod 选择默认合并 Pull Request 的方式,分别为 merge squash rebase (optional)
     * @param  string $issueTemplateSource Issue 模版来源 project: 使用仓库 Issue Template 作为模版； enterprise: 使用企业工作项作为模版 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchV5ReposOwnerRepoAsync($owner, $repo, $name, $accessToken = null, $description = null, $homepage = null, $hasIssues = 'true', $hasWiki = 'true', $canComment = 'true', $issueComment = null, $securityHoleEnabled = null, $private = null, $path = null, $defaultBranch = null, $pullRequestsEnabled = null, $onlineEditEnabled = null, $lightweightPrEnabled = null, $mergeEnabled = null, $squashEnabled = null, $rebaseEnabled = null, $defaultMergeMethod = null, $issueTemplateSource = null)
    {
        return $this->patchV5ReposOwnerRepoAsyncWithHttpInfo($owner, $repo, $name, $accessToken, $description, $homepage, $hasIssues, $hasWiki, $canComment, $issueComment, $securityHoleEnabled, $private, $path, $defaultBranch, $pullRequestsEnabled, $onlineEditEnabled, $lightweightPrEnabled, $mergeEnabled, $squashEnabled, $rebaseEnabled, $defaultMergeMethod, $issueTemplateSource)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchV5ReposOwnerRepoAsyncWithHttpInfo
     *
     * 更新仓库设置
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $name 仓库名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $description 仓库描述 (optional)
     * @param  string $homepage 主页(eg: https://gitee.com) (optional)
     * @param  bool $hasIssues 允许提Issue与否。默认: 允许(true) (optional, default to true)
     * @param  bool $hasWiki 提供Wiki与否。默认: 提供(true) (optional, default to true)
     * @param  bool $canComment 允许用户对仓库进行评论。默认： 允许(true) (optional, default to true)
     * @param  bool $issueComment 允许对“关闭”状态的 Issue 进行评论。默认: 不允许(false) (optional)
     * @param  bool $securityHoleEnabled 这个Issue涉及到安全/隐私问题，提交后不公开此Issue（可见范围：仓库成员, 企业成员） (optional)
     * @param  bool $private 仓库公开或私有。 (optional)
     * @param  string $path 更新仓库路径 (optional)
     * @param  string $defaultBranch 更新默认分支 (optional)
     * @param  bool $pullRequestsEnabled 接受 pull request，协作开发 (optional)
     * @param  bool $onlineEditEnabled 是否允许仓库文件在线编辑 (optional)
     * @param  bool $lightweightPrEnabled 是否接受轻量级 pull request (optional)
     * @param  bool $mergeEnabled 是否开启 merge 合并方式, 默认为开启 (optional)
     * @param  bool $squashEnabled 是否开启 squash 合并方式, 默认为开启 (optional)
     * @param  bool $rebaseEnabled 是否开启 rebase 合并方式, 默认为开启 (optional)
     * @param  string $defaultMergeMethod 选择默认合并 Pull Request 的方式,分别为 merge squash rebase (optional)
     * @param  string $issueTemplateSource Issue 模版来源 project: 使用仓库 Issue Template 作为模版； enterprise: 使用企业工作项作为模版 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchV5ReposOwnerRepoAsyncWithHttpInfo($owner, $repo, $name, $accessToken = null, $description = null, $homepage = null, $hasIssues = 'true', $hasWiki = 'true', $canComment = 'true', $issueComment = null, $securityHoleEnabled = null, $private = null, $path = null, $defaultBranch = null, $pullRequestsEnabled = null, $onlineEditEnabled = null, $lightweightPrEnabled = null, $mergeEnabled = null, $squashEnabled = null, $rebaseEnabled = null, $defaultMergeMethod = null, $issueTemplateSource = null)
    {
        $returnType = '\Gitee\Model\Project';
        $request = $this->patchV5ReposOwnerRepoRequest($owner, $repo, $name, $accessToken, $description, $homepage, $hasIssues, $hasWiki, $canComment, $issueComment, $securityHoleEnabled, $private, $path, $defaultBranch, $pullRequestsEnabled, $onlineEditEnabled, $lightweightPrEnabled, $mergeEnabled, $squashEnabled, $rebaseEnabled, $defaultMergeMethod, $issueTemplateSource);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchV5ReposOwnerRepo'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $name 仓库名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $description 仓库描述 (optional)
     * @param  string $homepage 主页(eg: https://gitee.com) (optional)
     * @param  bool $hasIssues 允许提Issue与否。默认: 允许(true) (optional, default to true)
     * @param  bool $hasWiki 提供Wiki与否。默认: 提供(true) (optional, default to true)
     * @param  bool $canComment 允许用户对仓库进行评论。默认： 允许(true) (optional, default to true)
     * @param  bool $issueComment 允许对“关闭”状态的 Issue 进行评论。默认: 不允许(false) (optional)
     * @param  bool $securityHoleEnabled 这个Issue涉及到安全/隐私问题，提交后不公开此Issue（可见范围：仓库成员, 企业成员） (optional)
     * @param  bool $private 仓库公开或私有。 (optional)
     * @param  string $path 更新仓库路径 (optional)
     * @param  string $defaultBranch 更新默认分支 (optional)
     * @param  bool $pullRequestsEnabled 接受 pull request，协作开发 (optional)
     * @param  bool $onlineEditEnabled 是否允许仓库文件在线编辑 (optional)
     * @param  bool $lightweightPrEnabled 是否接受轻量级 pull request (optional)
     * @param  bool $mergeEnabled 是否开启 merge 合并方式, 默认为开启 (optional)
     * @param  bool $squashEnabled 是否开启 squash 合并方式, 默认为开启 (optional)
     * @param  bool $rebaseEnabled 是否开启 rebase 合并方式, 默认为开启 (optional)
     * @param  string $defaultMergeMethod 选择默认合并 Pull Request 的方式,分别为 merge squash rebase (optional)
     * @param  string $issueTemplateSource Issue 模版来源 project: 使用仓库 Issue Template 作为模版； enterprise: 使用企业工作项作为模版 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchV5ReposOwnerRepoRequest($owner, $repo, $name, $accessToken = null, $description = null, $homepage = null, $hasIssues = 'true', $hasWiki = 'true', $canComment = 'true', $issueComment = null, $securityHoleEnabled = null, $private = null, $path = null, $defaultBranch = null, $pullRequestsEnabled = null, $onlineEditEnabled = null, $lightweightPrEnabled = null, $mergeEnabled = null, $squashEnabled = null, $rebaseEnabled = null, $defaultMergeMethod = null, $issueTemplateSource = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling patchV5ReposOwnerRepo'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling patchV5ReposOwnerRepo'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patchV5ReposOwnerRepo'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($description !== null) {
            $formParams['description'] = ObjectSerializer::toFormValue($description);
        }
        // form params
        if ($homepage !== null) {
            $formParams['homepage'] = ObjectSerializer::toFormValue($homepage);
        }
        // form params
        if ($hasIssues !== null) {
            $formParams['has_issues'] = ObjectSerializer::toFormValue($hasIssues);
        }
        // form params
        if ($hasWiki !== null) {
            $formParams['has_wiki'] = ObjectSerializer::toFormValue($hasWiki);
        }
        // form params
        if ($canComment !== null) {
            $formParams['can_comment'] = ObjectSerializer::toFormValue($canComment);
        }
        // form params
        if ($issueComment !== null) {
            $formParams['issue_comment'] = ObjectSerializer::toFormValue($issueComment);
        }
        // form params
        if ($securityHoleEnabled !== null) {
            $formParams['security_hole_enabled'] = ObjectSerializer::toFormValue($securityHoleEnabled);
        }
        // form params
        if ($private !== null) {
            $formParams['private'] = ObjectSerializer::toFormValue($private);
        }
        // form params
        if ($path !== null) {
            $formParams['path'] = ObjectSerializer::toFormValue($path);
        }
        // form params
        if ($defaultBranch !== null) {
            $formParams['default_branch'] = ObjectSerializer::toFormValue($defaultBranch);
        }
        // form params
        if ($pullRequestsEnabled !== null) {
            $formParams['pull_requests_enabled'] = ObjectSerializer::toFormValue($pullRequestsEnabled);
        }
        // form params
        if ($onlineEditEnabled !== null) {
            $formParams['online_edit_enabled'] = ObjectSerializer::toFormValue($onlineEditEnabled);
        }
        // form params
        if ($lightweightPrEnabled !== null) {
            $formParams['lightweight_pr_enabled'] = ObjectSerializer::toFormValue($lightweightPrEnabled);
        }
        // form params
        if ($mergeEnabled !== null) {
            $formParams['merge_enabled'] = ObjectSerializer::toFormValue($mergeEnabled);
        }
        // form params
        if ($squashEnabled !== null) {
            $formParams['squash_enabled'] = ObjectSerializer::toFormValue($squashEnabled);
        }
        // form params
        if ($rebaseEnabled !== null) {
            $formParams['rebase_enabled'] = ObjectSerializer::toFormValue($rebaseEnabled);
        }
        // form params
        if ($defaultMergeMethod !== null) {
            $formParams['default_merge_method'] = ObjectSerializer::toFormValue($defaultMergeMethod);
        }
        // form params
        if ($issueTemplateSource !== null) {
            $formParams['issue_template_source'] = ObjectSerializer::toFormValue($issueTemplateSource);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchV5ReposOwnerRepoCommentsId
     *
     * 更新Commit评论
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 评论的ID (required)
     * @param  string $body 评论的内容 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Note
     */
    public function patchV5ReposOwnerRepoCommentsId($owner, $repo, $id, $body, $accessToken = null)
    {
        list($response) = $this->patchV5ReposOwnerRepoCommentsIdWithHttpInfo($owner, $repo, $id, $body, $accessToken);
        return $response;
    }

    /**
     * Operation patchV5ReposOwnerRepoCommentsIdWithHttpInfo
     *
     * 更新Commit评论
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 评论的ID (required)
     * @param  string $body 评论的内容 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Note, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchV5ReposOwnerRepoCommentsIdWithHttpInfo($owner, $repo, $id, $body, $accessToken = null)
    {
        $returnType = '\Gitee\Model\Note';
        $request = $this->patchV5ReposOwnerRepoCommentsIdRequest($owner, $repo, $id, $body, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchV5ReposOwnerRepoCommentsIdAsync
     *
     * 更新Commit评论
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 评论的ID (required)
     * @param  string $body 评论的内容 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchV5ReposOwnerRepoCommentsIdAsync($owner, $repo, $id, $body, $accessToken = null)
    {
        return $this->patchV5ReposOwnerRepoCommentsIdAsyncWithHttpInfo($owner, $repo, $id, $body, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchV5ReposOwnerRepoCommentsIdAsyncWithHttpInfo
     *
     * 更新Commit评论
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 评论的ID (required)
     * @param  string $body 评论的内容 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchV5ReposOwnerRepoCommentsIdAsyncWithHttpInfo($owner, $repo, $id, $body, $accessToken = null)
    {
        $returnType = '\Gitee\Model\Note';
        $request = $this->patchV5ReposOwnerRepoCommentsIdRequest($owner, $repo, $id, $body, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchV5ReposOwnerRepoCommentsId'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 评论的ID (required)
     * @param  string $body 评论的内容 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchV5ReposOwnerRepoCommentsIdRequest($owner, $repo, $id, $body, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling patchV5ReposOwnerRepoCommentsId'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling patchV5ReposOwnerRepoCommentsId'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patchV5ReposOwnerRepoCommentsId'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling patchV5ReposOwnerRepoCommentsId'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/comments/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // form params
        if ($body !== null) {
            $formParams['body'] = ObjectSerializer::toFormValue($body);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchV5ReposOwnerRepoReleasesId
     *
     * 更新仓库Release
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $tagName Tag 名称, 提倡以v字母为前缀做为Release名称，例如v1.0或者v2.3.4 (required)
     * @param  string $name Release 名称 (required)
     * @param  string $body Release 描述 (required)
     * @param  int $id id (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  bool $prerelease 是否为预览版本。默认: false（非预览版本） (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Release
     */
    public function patchV5ReposOwnerRepoReleasesId($owner, $repo, $tagName, $name, $body, $id, $accessToken = null, $prerelease = null)
    {
        list($response) = $this->patchV5ReposOwnerRepoReleasesIdWithHttpInfo($owner, $repo, $tagName, $name, $body, $id, $accessToken, $prerelease);
        return $response;
    }

    /**
     * Operation patchV5ReposOwnerRepoReleasesIdWithHttpInfo
     *
     * 更新仓库Release
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $tagName Tag 名称, 提倡以v字母为前缀做为Release名称，例如v1.0或者v2.3.4 (required)
     * @param  string $name Release 名称 (required)
     * @param  string $body Release 描述 (required)
     * @param  int $id (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  bool $prerelease 是否为预览版本。默认: false（非预览版本） (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Release, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchV5ReposOwnerRepoReleasesIdWithHttpInfo($owner, $repo, $tagName, $name, $body, $id, $accessToken = null, $prerelease = null)
    {
        $returnType = '\Gitee\Model\Release';
        $request = $this->patchV5ReposOwnerRepoReleasesIdRequest($owner, $repo, $tagName, $name, $body, $id, $accessToken, $prerelease);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Release',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchV5ReposOwnerRepoReleasesIdAsync
     *
     * 更新仓库Release
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $tagName Tag 名称, 提倡以v字母为前缀做为Release名称，例如v1.0或者v2.3.4 (required)
     * @param  string $name Release 名称 (required)
     * @param  string $body Release 描述 (required)
     * @param  int $id (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  bool $prerelease 是否为预览版本。默认: false（非预览版本） (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchV5ReposOwnerRepoReleasesIdAsync($owner, $repo, $tagName, $name, $body, $id, $accessToken = null, $prerelease = null)
    {
        return $this->patchV5ReposOwnerRepoReleasesIdAsyncWithHttpInfo($owner, $repo, $tagName, $name, $body, $id, $accessToken, $prerelease)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchV5ReposOwnerRepoReleasesIdAsyncWithHttpInfo
     *
     * 更新仓库Release
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $tagName Tag 名称, 提倡以v字母为前缀做为Release名称，例如v1.0或者v2.3.4 (required)
     * @param  string $name Release 名称 (required)
     * @param  string $body Release 描述 (required)
     * @param  int $id (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  bool $prerelease 是否为预览版本。默认: false（非预览版本） (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchV5ReposOwnerRepoReleasesIdAsyncWithHttpInfo($owner, $repo, $tagName, $name, $body, $id, $accessToken = null, $prerelease = null)
    {
        $returnType = '\Gitee\Model\Release';
        $request = $this->patchV5ReposOwnerRepoReleasesIdRequest($owner, $repo, $tagName, $name, $body, $id, $accessToken, $prerelease);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchV5ReposOwnerRepoReleasesId'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $tagName Tag 名称, 提倡以v字母为前缀做为Release名称，例如v1.0或者v2.3.4 (required)
     * @param  string $name Release 名称 (required)
     * @param  string $body Release 描述 (required)
     * @param  int $id (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  bool $prerelease 是否为预览版本。默认: false（非预览版本） (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchV5ReposOwnerRepoReleasesIdRequest($owner, $repo, $tagName, $name, $body, $id, $accessToken = null, $prerelease = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling patchV5ReposOwnerRepoReleasesId'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling patchV5ReposOwnerRepoReleasesId'
            );
        }
        // verify the required parameter 'tagName' is set
        if ($tagName === null || (is_array($tagName) && count($tagName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tagName when calling patchV5ReposOwnerRepoReleasesId'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patchV5ReposOwnerRepoReleasesId'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling patchV5ReposOwnerRepoReleasesId'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patchV5ReposOwnerRepoReleasesId'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/releases/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // form params
        if ($tagName !== null) {
            $formParams['tag_name'] = ObjectSerializer::toFormValue($tagName);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($body !== null) {
            $formParams['body'] = ObjectSerializer::toFormValue($body);
        }
        // form params
        if ($prerelease !== null) {
            $formParams['prerelease'] = ObjectSerializer::toFormValue($prerelease);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postV5EnterprisesEnterpriseRepos
     *
     * 创建企业仓库
     *
     * @param  string $name 仓库名称 (required)
     * @param  string $enterprise 企业的路径(path/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $description 仓库描述 (optional)
     * @param  string $homepage 主页(eg: https://gitee.com) (optional)
     * @param  bool $hasIssues 允许提Issue与否。默认: 允许(true) (optional, default to true)
     * @param  bool $hasWiki 提供Wiki与否。默认: 提供(true) (optional, default to true)
     * @param  bool $canComment 允许用户对仓库进行评论。默认： 允许(true) (optional, default to true)
     * @param  bool $autoInit 值为true时则会用README初始化仓库。默认: 不初始化(false) (optional)
     * @param  string $gitignoreTemplate Git Ignore模版 (optional)
     * @param  string $licenseTemplate License模版 (optional)
     * @param  string $path 仓库路径 (optional)
     * @param  int $private 仓库开源类型。0(私有), 1(外部开源), 2(内部开源)。默认: 0 (optional, default to 0)
     * @param  bool $outsourced 值为true值为外包仓库, false值为内部仓库。默认: 内部仓库(false) (optional)
     * @param  string $projectCreator 负责人的username (optional)
     * @param  string $members 用逗号分开的仓库成员。如: member1,member2 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Project
     */
    public function postV5EnterprisesEnterpriseRepos($name, $enterprise, $accessToken = null, $description = null, $homepage = null, $hasIssues = 'true', $hasWiki = 'true', $canComment = 'true', $autoInit = null, $gitignoreTemplate = null, $licenseTemplate = null, $path = null, $private = '0', $outsourced = null, $projectCreator = null, $members = null)
    {
        list($response) = $this->postV5EnterprisesEnterpriseReposWithHttpInfo($name, $enterprise, $accessToken, $description, $homepage, $hasIssues, $hasWiki, $canComment, $autoInit, $gitignoreTemplate, $licenseTemplate, $path, $private, $outsourced, $projectCreator, $members);
        return $response;
    }

    /**
     * Operation postV5EnterprisesEnterpriseReposWithHttpInfo
     *
     * 创建企业仓库
     *
     * @param  string $name 仓库名称 (required)
     * @param  string $enterprise 企业的路径(path/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $description 仓库描述 (optional)
     * @param  string $homepage 主页(eg: https://gitee.com) (optional)
     * @param  bool $hasIssues 允许提Issue与否。默认: 允许(true) (optional, default to true)
     * @param  bool $hasWiki 提供Wiki与否。默认: 提供(true) (optional, default to true)
     * @param  bool $canComment 允许用户对仓库进行评论。默认： 允许(true) (optional, default to true)
     * @param  bool $autoInit 值为true时则会用README初始化仓库。默认: 不初始化(false) (optional)
     * @param  string $gitignoreTemplate Git Ignore模版 (optional)
     * @param  string $licenseTemplate License模版 (optional)
     * @param  string $path 仓库路径 (optional)
     * @param  int $private 仓库开源类型。0(私有), 1(外部开源), 2(内部开源)。默认: 0 (optional, default to 0)
     * @param  bool $outsourced 值为true值为外包仓库, false值为内部仓库。默认: 内部仓库(false) (optional)
     * @param  string $projectCreator 负责人的username (optional)
     * @param  string $members 用逗号分开的仓库成员。如: member1,member2 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Project, HTTP status code, HTTP response headers (array of strings)
     */
    public function postV5EnterprisesEnterpriseReposWithHttpInfo($name, $enterprise, $accessToken = null, $description = null, $homepage = null, $hasIssues = 'true', $hasWiki = 'true', $canComment = 'true', $autoInit = null, $gitignoreTemplate = null, $licenseTemplate = null, $path = null, $private = '0', $outsourced = null, $projectCreator = null, $members = null)
    {
        $returnType = '\Gitee\Model\Project';
        $request = $this->postV5EnterprisesEnterpriseReposRequest($name, $enterprise, $accessToken, $description, $homepage, $hasIssues, $hasWiki, $canComment, $autoInit, $gitignoreTemplate, $licenseTemplate, $path, $private, $outsourced, $projectCreator, $members);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Project',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postV5EnterprisesEnterpriseReposAsync
     *
     * 创建企业仓库
     *
     * @param  string $name 仓库名称 (required)
     * @param  string $enterprise 企业的路径(path/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $description 仓库描述 (optional)
     * @param  string $homepage 主页(eg: https://gitee.com) (optional)
     * @param  bool $hasIssues 允许提Issue与否。默认: 允许(true) (optional, default to true)
     * @param  bool $hasWiki 提供Wiki与否。默认: 提供(true) (optional, default to true)
     * @param  bool $canComment 允许用户对仓库进行评论。默认： 允许(true) (optional, default to true)
     * @param  bool $autoInit 值为true时则会用README初始化仓库。默认: 不初始化(false) (optional)
     * @param  string $gitignoreTemplate Git Ignore模版 (optional)
     * @param  string $licenseTemplate License模版 (optional)
     * @param  string $path 仓库路径 (optional)
     * @param  int $private 仓库开源类型。0(私有), 1(外部开源), 2(内部开源)。默认: 0 (optional, default to 0)
     * @param  bool $outsourced 值为true值为外包仓库, false值为内部仓库。默认: 内部仓库(false) (optional)
     * @param  string $projectCreator 负责人的username (optional)
     * @param  string $members 用逗号分开的仓库成员。如: member1,member2 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5EnterprisesEnterpriseReposAsync($name, $enterprise, $accessToken = null, $description = null, $homepage = null, $hasIssues = 'true', $hasWiki = 'true', $canComment = 'true', $autoInit = null, $gitignoreTemplate = null, $licenseTemplate = null, $path = null, $private = '0', $outsourced = null, $projectCreator = null, $members = null)
    {
        return $this->postV5EnterprisesEnterpriseReposAsyncWithHttpInfo($name, $enterprise, $accessToken, $description, $homepage, $hasIssues, $hasWiki, $canComment, $autoInit, $gitignoreTemplate, $licenseTemplate, $path, $private, $outsourced, $projectCreator, $members)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postV5EnterprisesEnterpriseReposAsyncWithHttpInfo
     *
     * 创建企业仓库
     *
     * @param  string $name 仓库名称 (required)
     * @param  string $enterprise 企业的路径(path/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $description 仓库描述 (optional)
     * @param  string $homepage 主页(eg: https://gitee.com) (optional)
     * @param  bool $hasIssues 允许提Issue与否。默认: 允许(true) (optional, default to true)
     * @param  bool $hasWiki 提供Wiki与否。默认: 提供(true) (optional, default to true)
     * @param  bool $canComment 允许用户对仓库进行评论。默认： 允许(true) (optional, default to true)
     * @param  bool $autoInit 值为true时则会用README初始化仓库。默认: 不初始化(false) (optional)
     * @param  string $gitignoreTemplate Git Ignore模版 (optional)
     * @param  string $licenseTemplate License模版 (optional)
     * @param  string $path 仓库路径 (optional)
     * @param  int $private 仓库开源类型。0(私有), 1(外部开源), 2(内部开源)。默认: 0 (optional, default to 0)
     * @param  bool $outsourced 值为true值为外包仓库, false值为内部仓库。默认: 内部仓库(false) (optional)
     * @param  string $projectCreator 负责人的username (optional)
     * @param  string $members 用逗号分开的仓库成员。如: member1,member2 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5EnterprisesEnterpriseReposAsyncWithHttpInfo($name, $enterprise, $accessToken = null, $description = null, $homepage = null, $hasIssues = 'true', $hasWiki = 'true', $canComment = 'true', $autoInit = null, $gitignoreTemplate = null, $licenseTemplate = null, $path = null, $private = '0', $outsourced = null, $projectCreator = null, $members = null)
    {
        $returnType = '\Gitee\Model\Project';
        $request = $this->postV5EnterprisesEnterpriseReposRequest($name, $enterprise, $accessToken, $description, $homepage, $hasIssues, $hasWiki, $canComment, $autoInit, $gitignoreTemplate, $licenseTemplate, $path, $private, $outsourced, $projectCreator, $members);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postV5EnterprisesEnterpriseRepos'
     *
     * @param  string $name 仓库名称 (required)
     * @param  string $enterprise 企业的路径(path/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $description 仓库描述 (optional)
     * @param  string $homepage 主页(eg: https://gitee.com) (optional)
     * @param  bool $hasIssues 允许提Issue与否。默认: 允许(true) (optional, default to true)
     * @param  bool $hasWiki 提供Wiki与否。默认: 提供(true) (optional, default to true)
     * @param  bool $canComment 允许用户对仓库进行评论。默认： 允许(true) (optional, default to true)
     * @param  bool $autoInit 值为true时则会用README初始化仓库。默认: 不初始化(false) (optional)
     * @param  string $gitignoreTemplate Git Ignore模版 (optional)
     * @param  string $licenseTemplate License模版 (optional)
     * @param  string $path 仓库路径 (optional)
     * @param  int $private 仓库开源类型。0(私有), 1(外部开源), 2(内部开源)。默认: 0 (optional, default to 0)
     * @param  bool $outsourced 值为true值为外包仓库, false值为内部仓库。默认: 内部仓库(false) (optional)
     * @param  string $projectCreator 负责人的username (optional)
     * @param  string $members 用逗号分开的仓库成员。如: member1,member2 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postV5EnterprisesEnterpriseReposRequest($name, $enterprise, $accessToken = null, $description = null, $homepage = null, $hasIssues = 'true', $hasWiki = 'true', $canComment = 'true', $autoInit = null, $gitignoreTemplate = null, $licenseTemplate = null, $path = null, $private = '0', $outsourced = null, $projectCreator = null, $members = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postV5EnterprisesEnterpriseRepos'
            );
        }
        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling postV5EnterprisesEnterpriseRepos'
            );
        }

        $resourcePath = '/v5/enterprises/{enterprise}/repos';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }

        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($description !== null) {
            $formParams['description'] = ObjectSerializer::toFormValue($description);
        }
        // form params
        if ($homepage !== null) {
            $formParams['homepage'] = ObjectSerializer::toFormValue($homepage);
        }
        // form params
        if ($hasIssues !== null) {
            $formParams['has_issues'] = ObjectSerializer::toFormValue($hasIssues);
        }
        // form params
        if ($hasWiki !== null) {
            $formParams['has_wiki'] = ObjectSerializer::toFormValue($hasWiki);
        }
        // form params
        if ($canComment !== null) {
            $formParams['can_comment'] = ObjectSerializer::toFormValue($canComment);
        }
        // form params
        if ($autoInit !== null) {
            $formParams['auto_init'] = ObjectSerializer::toFormValue($autoInit);
        }
        // form params
        if ($gitignoreTemplate !== null) {
            $formParams['gitignore_template'] = ObjectSerializer::toFormValue($gitignoreTemplate);
        }
        // form params
        if ($licenseTemplate !== null) {
            $formParams['license_template'] = ObjectSerializer::toFormValue($licenseTemplate);
        }
        // form params
        if ($path !== null) {
            $formParams['path'] = ObjectSerializer::toFormValue($path);
        }
        // form params
        if ($private !== null) {
            $formParams['private'] = ObjectSerializer::toFormValue($private);
        }
        // form params
        if ($outsourced !== null) {
            $formParams['outsourced'] = ObjectSerializer::toFormValue($outsourced);
        }
        // form params
        if ($projectCreator !== null) {
            $formParams['project_creator'] = ObjectSerializer::toFormValue($projectCreator);
        }
        // form params
        if ($members !== null) {
            $formParams['members'] = ObjectSerializer::toFormValue($members);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postV5OrgsOrgRepos
     *
     * 创建组织仓库
     *
     * @param  string $name 仓库名称 (required)
     * @param  string $org 组织的路径(path/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $description 仓库描述 (optional)
     * @param  string $homepage 主页(eg: https://gitee.com) (optional)
     * @param  bool $hasIssues 允许提Issue与否。默认: 允许(true) (optional, default to true)
     * @param  bool $hasWiki 提供Wiki与否。默认: 提供(true) (optional, default to true)
     * @param  bool $canComment 允许用户对仓库进行评论。默认： 允许(true) (optional, default to true)
     * @param  int $public 仓库开源类型。0(私有), 1(外部开源), 2(内部开源)，注：与private互斥，以public为主。 (optional)
     * @param  bool $private 仓库公开或私有。默认: 公开(false)，注：与public互斥，以public为主。 (optional)
     * @param  bool $autoInit 值为true时则会用README初始化仓库。默认: 不初始化(false) (optional)
     * @param  string $gitignoreTemplate Git Ignore模版 (optional)
     * @param  string $licenseTemplate License模版 (optional)
     * @param  string $path 仓库路径 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Project
     */
    public function postV5OrgsOrgRepos($name, $org, $accessToken = null, $description = null, $homepage = null, $hasIssues = 'true', $hasWiki = 'true', $canComment = 'true', $public = null, $private = null, $autoInit = null, $gitignoreTemplate = null, $licenseTemplate = null, $path = null)
    {
        list($response) = $this->postV5OrgsOrgReposWithHttpInfo($name, $org, $accessToken, $description, $homepage, $hasIssues, $hasWiki, $canComment, $public, $private, $autoInit, $gitignoreTemplate, $licenseTemplate, $path);
        return $response;
    }

    /**
     * Operation postV5OrgsOrgReposWithHttpInfo
     *
     * 创建组织仓库
     *
     * @param  string $name 仓库名称 (required)
     * @param  string $org 组织的路径(path/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $description 仓库描述 (optional)
     * @param  string $homepage 主页(eg: https://gitee.com) (optional)
     * @param  bool $hasIssues 允许提Issue与否。默认: 允许(true) (optional, default to true)
     * @param  bool $hasWiki 提供Wiki与否。默认: 提供(true) (optional, default to true)
     * @param  bool $canComment 允许用户对仓库进行评论。默认： 允许(true) (optional, default to true)
     * @param  int $public 仓库开源类型。0(私有), 1(外部开源), 2(内部开源)，注：与private互斥，以public为主。 (optional)
     * @param  bool $private 仓库公开或私有。默认: 公开(false)，注：与public互斥，以public为主。 (optional)
     * @param  bool $autoInit 值为true时则会用README初始化仓库。默认: 不初始化(false) (optional)
     * @param  string $gitignoreTemplate Git Ignore模版 (optional)
     * @param  string $licenseTemplate License模版 (optional)
     * @param  string $path 仓库路径 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Project, HTTP status code, HTTP response headers (array of strings)
     */
    public function postV5OrgsOrgReposWithHttpInfo($name, $org, $accessToken = null, $description = null, $homepage = null, $hasIssues = 'true', $hasWiki = 'true', $canComment = 'true', $public = null, $private = null, $autoInit = null, $gitignoreTemplate = null, $licenseTemplate = null, $path = null)
    {
        $returnType = '\Gitee\Model\Project';
        $request = $this->postV5OrgsOrgReposRequest($name, $org, $accessToken, $description, $homepage, $hasIssues, $hasWiki, $canComment, $public, $private, $autoInit, $gitignoreTemplate, $licenseTemplate, $path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Project',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postV5OrgsOrgReposAsync
     *
     * 创建组织仓库
     *
     * @param  string $name 仓库名称 (required)
     * @param  string $org 组织的路径(path/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $description 仓库描述 (optional)
     * @param  string $homepage 主页(eg: https://gitee.com) (optional)
     * @param  bool $hasIssues 允许提Issue与否。默认: 允许(true) (optional, default to true)
     * @param  bool $hasWiki 提供Wiki与否。默认: 提供(true) (optional, default to true)
     * @param  bool $canComment 允许用户对仓库进行评论。默认： 允许(true) (optional, default to true)
     * @param  int $public 仓库开源类型。0(私有), 1(外部开源), 2(内部开源)，注：与private互斥，以public为主。 (optional)
     * @param  bool $private 仓库公开或私有。默认: 公开(false)，注：与public互斥，以public为主。 (optional)
     * @param  bool $autoInit 值为true时则会用README初始化仓库。默认: 不初始化(false) (optional)
     * @param  string $gitignoreTemplate Git Ignore模版 (optional)
     * @param  string $licenseTemplate License模版 (optional)
     * @param  string $path 仓库路径 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5OrgsOrgReposAsync($name, $org, $accessToken = null, $description = null, $homepage = null, $hasIssues = 'true', $hasWiki = 'true', $canComment = 'true', $public = null, $private = null, $autoInit = null, $gitignoreTemplate = null, $licenseTemplate = null, $path = null)
    {
        return $this->postV5OrgsOrgReposAsyncWithHttpInfo($name, $org, $accessToken, $description, $homepage, $hasIssues, $hasWiki, $canComment, $public, $private, $autoInit, $gitignoreTemplate, $licenseTemplate, $path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postV5OrgsOrgReposAsyncWithHttpInfo
     *
     * 创建组织仓库
     *
     * @param  string $name 仓库名称 (required)
     * @param  string $org 组织的路径(path/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $description 仓库描述 (optional)
     * @param  string $homepage 主页(eg: https://gitee.com) (optional)
     * @param  bool $hasIssues 允许提Issue与否。默认: 允许(true) (optional, default to true)
     * @param  bool $hasWiki 提供Wiki与否。默认: 提供(true) (optional, default to true)
     * @param  bool $canComment 允许用户对仓库进行评论。默认： 允许(true) (optional, default to true)
     * @param  int $public 仓库开源类型。0(私有), 1(外部开源), 2(内部开源)，注：与private互斥，以public为主。 (optional)
     * @param  bool $private 仓库公开或私有。默认: 公开(false)，注：与public互斥，以public为主。 (optional)
     * @param  bool $autoInit 值为true时则会用README初始化仓库。默认: 不初始化(false) (optional)
     * @param  string $gitignoreTemplate Git Ignore模版 (optional)
     * @param  string $licenseTemplate License模版 (optional)
     * @param  string $path 仓库路径 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5OrgsOrgReposAsyncWithHttpInfo($name, $org, $accessToken = null, $description = null, $homepage = null, $hasIssues = 'true', $hasWiki = 'true', $canComment = 'true', $public = null, $private = null, $autoInit = null, $gitignoreTemplate = null, $licenseTemplate = null, $path = null)
    {
        $returnType = '\Gitee\Model\Project';
        $request = $this->postV5OrgsOrgReposRequest($name, $org, $accessToken, $description, $homepage, $hasIssues, $hasWiki, $canComment, $public, $private, $autoInit, $gitignoreTemplate, $licenseTemplate, $path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postV5OrgsOrgRepos'
     *
     * @param  string $name 仓库名称 (required)
     * @param  string $org 组织的路径(path/login) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $description 仓库描述 (optional)
     * @param  string $homepage 主页(eg: https://gitee.com) (optional)
     * @param  bool $hasIssues 允许提Issue与否。默认: 允许(true) (optional, default to true)
     * @param  bool $hasWiki 提供Wiki与否。默认: 提供(true) (optional, default to true)
     * @param  bool $canComment 允许用户对仓库进行评论。默认： 允许(true) (optional, default to true)
     * @param  int $public 仓库开源类型。0(私有), 1(外部开源), 2(内部开源)，注：与private互斥，以public为主。 (optional)
     * @param  bool $private 仓库公开或私有。默认: 公开(false)，注：与public互斥，以public为主。 (optional)
     * @param  bool $autoInit 值为true时则会用README初始化仓库。默认: 不初始化(false) (optional)
     * @param  string $gitignoreTemplate Git Ignore模版 (optional)
     * @param  string $licenseTemplate License模版 (optional)
     * @param  string $path 仓库路径 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postV5OrgsOrgReposRequest($name, $org, $accessToken = null, $description = null, $homepage = null, $hasIssues = 'true', $hasWiki = 'true', $canComment = 'true', $public = null, $private = null, $autoInit = null, $gitignoreTemplate = null, $licenseTemplate = null, $path = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postV5OrgsOrgRepos'
            );
        }
        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling postV5OrgsOrgRepos'
            );
        }

        $resourcePath = '/v5/orgs/{org}/repos';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }

        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($description !== null) {
            $formParams['description'] = ObjectSerializer::toFormValue($description);
        }
        // form params
        if ($homepage !== null) {
            $formParams['homepage'] = ObjectSerializer::toFormValue($homepage);
        }
        // form params
        if ($hasIssues !== null) {
            $formParams['has_issues'] = ObjectSerializer::toFormValue($hasIssues);
        }
        // form params
        if ($hasWiki !== null) {
            $formParams['has_wiki'] = ObjectSerializer::toFormValue($hasWiki);
        }
        // form params
        if ($canComment !== null) {
            $formParams['can_comment'] = ObjectSerializer::toFormValue($canComment);
        }
        // form params
        if ($public !== null) {
            $formParams['public'] = ObjectSerializer::toFormValue($public);
        }
        // form params
        if ($private !== null) {
            $formParams['private'] = ObjectSerializer::toFormValue($private);
        }
        // form params
        if ($autoInit !== null) {
            $formParams['auto_init'] = ObjectSerializer::toFormValue($autoInit);
        }
        // form params
        if ($gitignoreTemplate !== null) {
            $formParams['gitignore_template'] = ObjectSerializer::toFormValue($gitignoreTemplate);
        }
        // form params
        if ($licenseTemplate !== null) {
            $formParams['license_template'] = ObjectSerializer::toFormValue($licenseTemplate);
        }
        // form params
        if ($path !== null) {
            $formParams['path'] = ObjectSerializer::toFormValue($path);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postV5ReposOwnerRepoBaiduStatisticKey
     *
     * 设置/更新仓库的百度统计 key
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $key 通过百度统计页面获取的 hm.js? 后面的 key (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postV5ReposOwnerRepoBaiduStatisticKey($owner, $repo, $accessToken = null, $key = null)
    {
        $this->postV5ReposOwnerRepoBaiduStatisticKeyWithHttpInfo($owner, $repo, $accessToken, $key);
    }

    /**
     * Operation postV5ReposOwnerRepoBaiduStatisticKeyWithHttpInfo
     *
     * 设置/更新仓库的百度统计 key
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $key 通过百度统计页面获取的 hm.js? 后面的 key (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postV5ReposOwnerRepoBaiduStatisticKeyWithHttpInfo($owner, $repo, $accessToken = null, $key = null)
    {
        $returnType = '';
        $request = $this->postV5ReposOwnerRepoBaiduStatisticKeyRequest($owner, $repo, $accessToken, $key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postV5ReposOwnerRepoBaiduStatisticKeyAsync
     *
     * 设置/更新仓库的百度统计 key
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $key 通过百度统计页面获取的 hm.js? 后面的 key (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5ReposOwnerRepoBaiduStatisticKeyAsync($owner, $repo, $accessToken = null, $key = null)
    {
        return $this->postV5ReposOwnerRepoBaiduStatisticKeyAsyncWithHttpInfo($owner, $repo, $accessToken, $key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postV5ReposOwnerRepoBaiduStatisticKeyAsyncWithHttpInfo
     *
     * 设置/更新仓库的百度统计 key
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $key 通过百度统计页面获取的 hm.js? 后面的 key (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5ReposOwnerRepoBaiduStatisticKeyAsyncWithHttpInfo($owner, $repo, $accessToken = null, $key = null)
    {
        $returnType = '';
        $request = $this->postV5ReposOwnerRepoBaiduStatisticKeyRequest($owner, $repo, $accessToken, $key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postV5ReposOwnerRepoBaiduStatisticKey'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $key 通过百度统计页面获取的 hm.js? 后面的 key (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postV5ReposOwnerRepoBaiduStatisticKeyRequest($owner, $repo, $accessToken = null, $key = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling postV5ReposOwnerRepoBaiduStatisticKey'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling postV5ReposOwnerRepoBaiduStatisticKey'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/baidu_statistic_key';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // form params
        if ($key !== null) {
            $formParams['key'] = ObjectSerializer::toFormValue($key);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postV5ReposOwnerRepoBranches
     *
     * 创建分支
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $refs 起点名称, 默认：master (required)
     * @param  string $branchName 新创建的分支名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\CompleteBranch
     */
    public function postV5ReposOwnerRepoBranches($owner, $repo, $refs, $branchName, $accessToken = null)
    {
        list($response) = $this->postV5ReposOwnerRepoBranchesWithHttpInfo($owner, $repo, $refs, $branchName, $accessToken);
        return $response;
    }

    /**
     * Operation postV5ReposOwnerRepoBranchesWithHttpInfo
     *
     * 创建分支
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $refs 起点名称, 默认：master (required)
     * @param  string $branchName 新创建的分支名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\CompleteBranch, HTTP status code, HTTP response headers (array of strings)
     */
    public function postV5ReposOwnerRepoBranchesWithHttpInfo($owner, $repo, $refs, $branchName, $accessToken = null)
    {
        $returnType = '\Gitee\Model\CompleteBranch';
        $request = $this->postV5ReposOwnerRepoBranchesRequest($owner, $repo, $refs, $branchName, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\CompleteBranch',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postV5ReposOwnerRepoBranchesAsync
     *
     * 创建分支
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $refs 起点名称, 默认：master (required)
     * @param  string $branchName 新创建的分支名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5ReposOwnerRepoBranchesAsync($owner, $repo, $refs, $branchName, $accessToken = null)
    {
        return $this->postV5ReposOwnerRepoBranchesAsyncWithHttpInfo($owner, $repo, $refs, $branchName, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postV5ReposOwnerRepoBranchesAsyncWithHttpInfo
     *
     * 创建分支
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $refs 起点名称, 默认：master (required)
     * @param  string $branchName 新创建的分支名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5ReposOwnerRepoBranchesAsyncWithHttpInfo($owner, $repo, $refs, $branchName, $accessToken = null)
    {
        $returnType = '\Gitee\Model\CompleteBranch';
        $request = $this->postV5ReposOwnerRepoBranchesRequest($owner, $repo, $refs, $branchName, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postV5ReposOwnerRepoBranches'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $refs 起点名称, 默认：master (required)
     * @param  string $branchName 新创建的分支名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postV5ReposOwnerRepoBranchesRequest($owner, $repo, $refs, $branchName, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling postV5ReposOwnerRepoBranches'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling postV5ReposOwnerRepoBranches'
            );
        }
        // verify the required parameter 'refs' is set
        if ($refs === null || (is_array($refs) && count($refs) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $refs when calling postV5ReposOwnerRepoBranches'
            );
        }
        // verify the required parameter 'branchName' is set
        if ($branchName === null || (is_array($branchName) && count($branchName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $branchName when calling postV5ReposOwnerRepoBranches'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/branches';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // form params
        if ($refs !== null) {
            $formParams['refs'] = ObjectSerializer::toFormValue($refs);
        }
        // form params
        if ($branchName !== null) {
            $formParams['branch_name'] = ObjectSerializer::toFormValue($branchName);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postV5ReposOwnerRepoCommits
     *
     * 提交多个文件变更
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  \Gitee\Model\PostV5ReposOwnerRepoCommits $v5ReposOwnerRepoCommits v5ReposOwnerRepoCommits (required)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\RepoCommitWithFiles
     */
    public function postV5ReposOwnerRepoCommits($owner, $repo, $v5ReposOwnerRepoCommits)
    {
        list($response) = $this->postV5ReposOwnerRepoCommitsWithHttpInfo($owner, $repo, $v5ReposOwnerRepoCommits);
        return $response;
    }

    /**
     * Operation postV5ReposOwnerRepoCommitsWithHttpInfo
     *
     * 提交多个文件变更
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  \Gitee\Model\PostV5ReposOwnerRepoCommits $v5ReposOwnerRepoCommits (required)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\RepoCommitWithFiles, HTTP status code, HTTP response headers (array of strings)
     */
    public function postV5ReposOwnerRepoCommitsWithHttpInfo($owner, $repo, $v5ReposOwnerRepoCommits)
    {
        $returnType = '\Gitee\Model\RepoCommitWithFiles';
        $request = $this->postV5ReposOwnerRepoCommitsRequest($owner, $repo, $v5ReposOwnerRepoCommits);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\RepoCommitWithFiles',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postV5ReposOwnerRepoCommitsAsync
     *
     * 提交多个文件变更
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  \Gitee\Model\PostV5ReposOwnerRepoCommits $v5ReposOwnerRepoCommits (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5ReposOwnerRepoCommitsAsync($owner, $repo, $v5ReposOwnerRepoCommits)
    {
        return $this->postV5ReposOwnerRepoCommitsAsyncWithHttpInfo($owner, $repo, $v5ReposOwnerRepoCommits)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postV5ReposOwnerRepoCommitsAsyncWithHttpInfo
     *
     * 提交多个文件变更
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  \Gitee\Model\PostV5ReposOwnerRepoCommits $v5ReposOwnerRepoCommits (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5ReposOwnerRepoCommitsAsyncWithHttpInfo($owner, $repo, $v5ReposOwnerRepoCommits)
    {
        $returnType = '\Gitee\Model\RepoCommitWithFiles';
        $request = $this->postV5ReposOwnerRepoCommitsRequest($owner, $repo, $v5ReposOwnerRepoCommits);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postV5ReposOwnerRepoCommits'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  \Gitee\Model\PostV5ReposOwnerRepoCommits $v5ReposOwnerRepoCommits (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postV5ReposOwnerRepoCommitsRequest($owner, $repo, $v5ReposOwnerRepoCommits)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling postV5ReposOwnerRepoCommits'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling postV5ReposOwnerRepoCommits'
            );
        }
        // verify the required parameter 'v5ReposOwnerRepoCommits' is set
        if ($v5ReposOwnerRepoCommits === null || (is_array($v5ReposOwnerRepoCommits) && count($v5ReposOwnerRepoCommits) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $v5ReposOwnerRepoCommits when calling postV5ReposOwnerRepoCommits'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/commits';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($v5ReposOwnerRepoCommits)) {
            $_tempBody = $v5ReposOwnerRepoCommits;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postV5ReposOwnerRepoCommitsShaComments
     *
     * 创建Commit评论
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $sha 评论的sha值 (required)
     * @param  string $body 评论的内容 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $path 文件的相对路径 (optional)
     * @param  int $position Diff的相对行数 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Note
     */
    public function postV5ReposOwnerRepoCommitsShaComments($owner, $repo, $sha, $body, $accessToken = null, $path = null, $position = null)
    {
        list($response) = $this->postV5ReposOwnerRepoCommitsShaCommentsWithHttpInfo($owner, $repo, $sha, $body, $accessToken, $path, $position);
        return $response;
    }

    /**
     * Operation postV5ReposOwnerRepoCommitsShaCommentsWithHttpInfo
     *
     * 创建Commit评论
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $sha 评论的sha值 (required)
     * @param  string $body 评论的内容 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $path 文件的相对路径 (optional)
     * @param  int $position Diff的相对行数 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Note, HTTP status code, HTTP response headers (array of strings)
     */
    public function postV5ReposOwnerRepoCommitsShaCommentsWithHttpInfo($owner, $repo, $sha, $body, $accessToken = null, $path = null, $position = null)
    {
        $returnType = '\Gitee\Model\Note';
        $request = $this->postV5ReposOwnerRepoCommitsShaCommentsRequest($owner, $repo, $sha, $body, $accessToken, $path, $position);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postV5ReposOwnerRepoCommitsShaCommentsAsync
     *
     * 创建Commit评论
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $sha 评论的sha值 (required)
     * @param  string $body 评论的内容 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $path 文件的相对路径 (optional)
     * @param  int $position Diff的相对行数 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5ReposOwnerRepoCommitsShaCommentsAsync($owner, $repo, $sha, $body, $accessToken = null, $path = null, $position = null)
    {
        return $this->postV5ReposOwnerRepoCommitsShaCommentsAsyncWithHttpInfo($owner, $repo, $sha, $body, $accessToken, $path, $position)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postV5ReposOwnerRepoCommitsShaCommentsAsyncWithHttpInfo
     *
     * 创建Commit评论
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $sha 评论的sha值 (required)
     * @param  string $body 评论的内容 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $path 文件的相对路径 (optional)
     * @param  int $position Diff的相对行数 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5ReposOwnerRepoCommitsShaCommentsAsyncWithHttpInfo($owner, $repo, $sha, $body, $accessToken = null, $path = null, $position = null)
    {
        $returnType = '\Gitee\Model\Note';
        $request = $this->postV5ReposOwnerRepoCommitsShaCommentsRequest($owner, $repo, $sha, $body, $accessToken, $path, $position);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postV5ReposOwnerRepoCommitsShaComments'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $sha 评论的sha值 (required)
     * @param  string $body 评论的内容 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $path 文件的相对路径 (optional)
     * @param  int $position Diff的相对行数 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postV5ReposOwnerRepoCommitsShaCommentsRequest($owner, $repo, $sha, $body, $accessToken = null, $path = null, $position = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling postV5ReposOwnerRepoCommitsShaComments'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling postV5ReposOwnerRepoCommitsShaComments'
            );
        }
        // verify the required parameter 'sha' is set
        if ($sha === null || (is_array($sha) && count($sha) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sha when calling postV5ReposOwnerRepoCommitsShaComments'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postV5ReposOwnerRepoCommitsShaComments'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/commits/{sha}/comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($sha !== null) {
            $resourcePath = str_replace(
                '{' . 'sha' . '}',
                ObjectSerializer::toPathValue($sha),
                $resourcePath
            );
        }

        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // form params
        if ($body !== null) {
            $formParams['body'] = ObjectSerializer::toFormValue($body);
        }
        // form params
        if ($path !== null) {
            $formParams['path'] = ObjectSerializer::toFormValue($path);
        }
        // form params
        if ($position !== null) {
            $formParams['position'] = ObjectSerializer::toFormValue($position);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postV5ReposOwnerRepoContentsPath
     *
     * 新建文件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径 (required)
     * @param  string $content 文件内容, 要用 base64 编码 (required)
     * @param  string $message 提交信息 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $branch 分支名称。默认为仓库对默认分支 (optional)
     * @param  string $committerName Committer的名字，默认为当前用户的名字 (optional)
     * @param  string $committerEmail Committer的邮箱，默认为当前用户的邮箱 (optional)
     * @param  string $authorName Author的名字，默认为当前用户的名字 (optional)
     * @param  string $authorEmail Author的邮箱，默认为当前用户的邮箱 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\CommitContent
     */
    public function postV5ReposOwnerRepoContentsPath($owner, $repo, $path, $content, $message, $accessToken = null, $branch = null, $committerName = null, $committerEmail = null, $authorName = null, $authorEmail = null)
    {
        list($response) = $this->postV5ReposOwnerRepoContentsPathWithHttpInfo($owner, $repo, $path, $content, $message, $accessToken, $branch, $committerName, $committerEmail, $authorName, $authorEmail);
        return $response;
    }

    /**
     * Operation postV5ReposOwnerRepoContentsPathWithHttpInfo
     *
     * 新建文件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径 (required)
     * @param  string $content 文件内容, 要用 base64 编码 (required)
     * @param  string $message 提交信息 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $branch 分支名称。默认为仓库对默认分支 (optional)
     * @param  string $committerName Committer的名字，默认为当前用户的名字 (optional)
     * @param  string $committerEmail Committer的邮箱，默认为当前用户的邮箱 (optional)
     * @param  string $authorName Author的名字，默认为当前用户的名字 (optional)
     * @param  string $authorEmail Author的邮箱，默认为当前用户的邮箱 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\CommitContent, HTTP status code, HTTP response headers (array of strings)
     */
    public function postV5ReposOwnerRepoContentsPathWithHttpInfo($owner, $repo, $path, $content, $message, $accessToken = null, $branch = null, $committerName = null, $committerEmail = null, $authorName = null, $authorEmail = null)
    {
        $returnType = '\Gitee\Model\CommitContent';
        $request = $this->postV5ReposOwnerRepoContentsPathRequest($owner, $repo, $path, $content, $message, $accessToken, $branch, $committerName, $committerEmail, $authorName, $authorEmail);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\CommitContent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postV5ReposOwnerRepoContentsPathAsync
     *
     * 新建文件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径 (required)
     * @param  string $content 文件内容, 要用 base64 编码 (required)
     * @param  string $message 提交信息 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $branch 分支名称。默认为仓库对默认分支 (optional)
     * @param  string $committerName Committer的名字，默认为当前用户的名字 (optional)
     * @param  string $committerEmail Committer的邮箱，默认为当前用户的邮箱 (optional)
     * @param  string $authorName Author的名字，默认为当前用户的名字 (optional)
     * @param  string $authorEmail Author的邮箱，默认为当前用户的邮箱 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5ReposOwnerRepoContentsPathAsync($owner, $repo, $path, $content, $message, $accessToken = null, $branch = null, $committerName = null, $committerEmail = null, $authorName = null, $authorEmail = null)
    {
        return $this->postV5ReposOwnerRepoContentsPathAsyncWithHttpInfo($owner, $repo, $path, $content, $message, $accessToken, $branch, $committerName, $committerEmail, $authorName, $authorEmail)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postV5ReposOwnerRepoContentsPathAsyncWithHttpInfo
     *
     * 新建文件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径 (required)
     * @param  string $content 文件内容, 要用 base64 编码 (required)
     * @param  string $message 提交信息 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $branch 分支名称。默认为仓库对默认分支 (optional)
     * @param  string $committerName Committer的名字，默认为当前用户的名字 (optional)
     * @param  string $committerEmail Committer的邮箱，默认为当前用户的邮箱 (optional)
     * @param  string $authorName Author的名字，默认为当前用户的名字 (optional)
     * @param  string $authorEmail Author的邮箱，默认为当前用户的邮箱 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5ReposOwnerRepoContentsPathAsyncWithHttpInfo($owner, $repo, $path, $content, $message, $accessToken = null, $branch = null, $committerName = null, $committerEmail = null, $authorName = null, $authorEmail = null)
    {
        $returnType = '\Gitee\Model\CommitContent';
        $request = $this->postV5ReposOwnerRepoContentsPathRequest($owner, $repo, $path, $content, $message, $accessToken, $branch, $committerName, $committerEmail, $authorName, $authorEmail);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postV5ReposOwnerRepoContentsPath'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径 (required)
     * @param  string $content 文件内容, 要用 base64 编码 (required)
     * @param  string $message 提交信息 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $branch 分支名称。默认为仓库对默认分支 (optional)
     * @param  string $committerName Committer的名字，默认为当前用户的名字 (optional)
     * @param  string $committerEmail Committer的邮箱，默认为当前用户的邮箱 (optional)
     * @param  string $authorName Author的名字，默认为当前用户的名字 (optional)
     * @param  string $authorEmail Author的邮箱，默认为当前用户的邮箱 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postV5ReposOwnerRepoContentsPathRequest($owner, $repo, $path, $content, $message, $accessToken = null, $branch = null, $committerName = null, $committerEmail = null, $authorName = null, $authorEmail = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling postV5ReposOwnerRepoContentsPath'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling postV5ReposOwnerRepoContentsPath'
            );
        }
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling postV5ReposOwnerRepoContentsPath'
            );
        }
        // verify the required parameter 'content' is set
        if ($content === null || (is_array($content) && count($content) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content when calling postV5ReposOwnerRepoContentsPath'
            );
        }
        // verify the required parameter 'message' is set
        if ($message === null || (is_array($message) && count($message) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message when calling postV5ReposOwnerRepoContentsPath'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/contents/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                '{' . 'path' . '}',
                ObjectSerializer::toPathValue($path),
                $resourcePath
            );
        }

        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // form params
        if ($content !== null) {
            $formParams['content'] = ObjectSerializer::toFormValue($content);
        }
        // form params
        if ($message !== null) {
            $formParams['message'] = ObjectSerializer::toFormValue($message);
        }
        // form params
        if ($branch !== null) {
            $formParams['branch'] = ObjectSerializer::toFormValue($branch);
        }
        // form params
        if ($committerName !== null) {
            $formParams['committer[name]'] = ObjectSerializer::toFormValue($committerName);
        }
        // form params
        if ($committerEmail !== null) {
            $formParams['committer[email]'] = ObjectSerializer::toFormValue($committerEmail);
        }
        // form params
        if ($authorName !== null) {
            $formParams['author[name]'] = ObjectSerializer::toFormValue($authorName);
        }
        // form params
        if ($authorEmail !== null) {
            $formParams['author[email]'] = ObjectSerializer::toFormValue($authorEmail);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postV5ReposOwnerRepoForks
     *
     * Fork一个仓库
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $organization 组织空间完整地址，不填写默认Fork到用户个人空间地址 (optional)
     * @param  string $name fork 后仓库名称。默认: 源仓库名称 (optional)
     * @param  string $path fork 后仓库地址。默认: 源仓库地址 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Project
     */
    public function postV5ReposOwnerRepoForks($owner, $repo, $accessToken = null, $organization = null, $name = null, $path = null)
    {
        list($response) = $this->postV5ReposOwnerRepoForksWithHttpInfo($owner, $repo, $accessToken, $organization, $name, $path);
        return $response;
    }

    /**
     * Operation postV5ReposOwnerRepoForksWithHttpInfo
     *
     * Fork一个仓库
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $organization 组织空间完整地址，不填写默认Fork到用户个人空间地址 (optional)
     * @param  string $name fork 后仓库名称。默认: 源仓库名称 (optional)
     * @param  string $path fork 后仓库地址。默认: 源仓库地址 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Project, HTTP status code, HTTP response headers (array of strings)
     */
    public function postV5ReposOwnerRepoForksWithHttpInfo($owner, $repo, $accessToken = null, $organization = null, $name = null, $path = null)
    {
        $returnType = '\Gitee\Model\Project';
        $request = $this->postV5ReposOwnerRepoForksRequest($owner, $repo, $accessToken, $organization, $name, $path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Project',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postV5ReposOwnerRepoForksAsync
     *
     * Fork一个仓库
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $organization 组织空间完整地址，不填写默认Fork到用户个人空间地址 (optional)
     * @param  string $name fork 后仓库名称。默认: 源仓库名称 (optional)
     * @param  string $path fork 后仓库地址。默认: 源仓库地址 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5ReposOwnerRepoForksAsync($owner, $repo, $accessToken = null, $organization = null, $name = null, $path = null)
    {
        return $this->postV5ReposOwnerRepoForksAsyncWithHttpInfo($owner, $repo, $accessToken, $organization, $name, $path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postV5ReposOwnerRepoForksAsyncWithHttpInfo
     *
     * Fork一个仓库
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $organization 组织空间完整地址，不填写默认Fork到用户个人空间地址 (optional)
     * @param  string $name fork 后仓库名称。默认: 源仓库名称 (optional)
     * @param  string $path fork 后仓库地址。默认: 源仓库地址 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5ReposOwnerRepoForksAsyncWithHttpInfo($owner, $repo, $accessToken = null, $organization = null, $name = null, $path = null)
    {
        $returnType = '\Gitee\Model\Project';
        $request = $this->postV5ReposOwnerRepoForksRequest($owner, $repo, $accessToken, $organization, $name, $path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postV5ReposOwnerRepoForks'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $organization 组织空间完整地址，不填写默认Fork到用户个人空间地址 (optional)
     * @param  string $name fork 后仓库名称。默认: 源仓库名称 (optional)
     * @param  string $path fork 后仓库地址。默认: 源仓库地址 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postV5ReposOwnerRepoForksRequest($owner, $repo, $accessToken = null, $organization = null, $name = null, $path = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling postV5ReposOwnerRepoForks'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling postV5ReposOwnerRepoForks'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/forks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // form params
        if ($organization !== null) {
            $formParams['organization'] = ObjectSerializer::toFormValue($organization);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($path !== null) {
            $formParams['path'] = ObjectSerializer::toFormValue($path);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postV5ReposOwnerRepoKeys
     *
     * 为仓库添加公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $key 公钥内容 (required)
     * @param  string $title 公钥名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\SSHKey
     */
    public function postV5ReposOwnerRepoKeys($owner, $repo, $key, $title, $accessToken = null)
    {
        list($response) = $this->postV5ReposOwnerRepoKeysWithHttpInfo($owner, $repo, $key, $title, $accessToken);
        return $response;
    }

    /**
     * Operation postV5ReposOwnerRepoKeysWithHttpInfo
     *
     * 为仓库添加公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $key 公钥内容 (required)
     * @param  string $title 公钥名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\SSHKey, HTTP status code, HTTP response headers (array of strings)
     */
    public function postV5ReposOwnerRepoKeysWithHttpInfo($owner, $repo, $key, $title, $accessToken = null)
    {
        $returnType = '\Gitee\Model\SSHKey';
        $request = $this->postV5ReposOwnerRepoKeysRequest($owner, $repo, $key, $title, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\SSHKey',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postV5ReposOwnerRepoKeysAsync
     *
     * 为仓库添加公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $key 公钥内容 (required)
     * @param  string $title 公钥名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5ReposOwnerRepoKeysAsync($owner, $repo, $key, $title, $accessToken = null)
    {
        return $this->postV5ReposOwnerRepoKeysAsyncWithHttpInfo($owner, $repo, $key, $title, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postV5ReposOwnerRepoKeysAsyncWithHttpInfo
     *
     * 为仓库添加公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $key 公钥内容 (required)
     * @param  string $title 公钥名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5ReposOwnerRepoKeysAsyncWithHttpInfo($owner, $repo, $key, $title, $accessToken = null)
    {
        $returnType = '\Gitee\Model\SSHKey';
        $request = $this->postV5ReposOwnerRepoKeysRequest($owner, $repo, $key, $title, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postV5ReposOwnerRepoKeys'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $key 公钥内容 (required)
     * @param  string $title 公钥名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postV5ReposOwnerRepoKeysRequest($owner, $repo, $key, $title, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling postV5ReposOwnerRepoKeys'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling postV5ReposOwnerRepoKeys'
            );
        }
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling postV5ReposOwnerRepoKeys'
            );
        }
        // verify the required parameter 'title' is set
        if ($title === null || (is_array($title) && count($title) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $title when calling postV5ReposOwnerRepoKeys'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/keys';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // form params
        if ($key !== null) {
            $formParams['key'] = ObjectSerializer::toFormValue($key);
        }
        // form params
        if ($title !== null) {
            $formParams['title'] = ObjectSerializer::toFormValue($title);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postV5ReposOwnerRepoOpen
     *
     * 开通Gitee Go
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库path (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postV5ReposOwnerRepoOpen($owner, $repo, $accessToken = null)
    {
        $this->postV5ReposOwnerRepoOpenWithHttpInfo($owner, $repo, $accessToken);
    }

    /**
     * Operation postV5ReposOwnerRepoOpenWithHttpInfo
     *
     * 开通Gitee Go
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库path (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postV5ReposOwnerRepoOpenWithHttpInfo($owner, $repo, $accessToken = null)
    {
        $returnType = '';
        $request = $this->postV5ReposOwnerRepoOpenRequest($owner, $repo, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postV5ReposOwnerRepoOpenAsync
     *
     * 开通Gitee Go
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库path (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5ReposOwnerRepoOpenAsync($owner, $repo, $accessToken = null)
    {
        return $this->postV5ReposOwnerRepoOpenAsyncWithHttpInfo($owner, $repo, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postV5ReposOwnerRepoOpenAsyncWithHttpInfo
     *
     * 开通Gitee Go
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库path (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5ReposOwnerRepoOpenAsyncWithHttpInfo($owner, $repo, $accessToken = null)
    {
        $returnType = '';
        $request = $this->postV5ReposOwnerRepoOpenRequest($owner, $repo, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postV5ReposOwnerRepoOpen'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库path (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postV5ReposOwnerRepoOpenRequest($owner, $repo, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling postV5ReposOwnerRepoOpen'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling postV5ReposOwnerRepoOpen'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/open';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postV5ReposOwnerRepoPagesBuilds
     *
     * 请求建立Pages
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postV5ReposOwnerRepoPagesBuilds($owner, $repo, $accessToken = null)
    {
        $this->postV5ReposOwnerRepoPagesBuildsWithHttpInfo($owner, $repo, $accessToken);
    }

    /**
     * Operation postV5ReposOwnerRepoPagesBuildsWithHttpInfo
     *
     * 请求建立Pages
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postV5ReposOwnerRepoPagesBuildsWithHttpInfo($owner, $repo, $accessToken = null)
    {
        $returnType = '';
        $request = $this->postV5ReposOwnerRepoPagesBuildsRequest($owner, $repo, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postV5ReposOwnerRepoPagesBuildsAsync
     *
     * 请求建立Pages
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5ReposOwnerRepoPagesBuildsAsync($owner, $repo, $accessToken = null)
    {
        return $this->postV5ReposOwnerRepoPagesBuildsAsyncWithHttpInfo($owner, $repo, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postV5ReposOwnerRepoPagesBuildsAsyncWithHttpInfo
     *
     * 请求建立Pages
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5ReposOwnerRepoPagesBuildsAsyncWithHttpInfo($owner, $repo, $accessToken = null)
    {
        $returnType = '';
        $request = $this->postV5ReposOwnerRepoPagesBuildsRequest($owner, $repo, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postV5ReposOwnerRepoPagesBuilds'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postV5ReposOwnerRepoPagesBuildsRequest($owner, $repo, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling postV5ReposOwnerRepoPagesBuilds'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling postV5ReposOwnerRepoPagesBuilds'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/pages/builds';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postV5ReposOwnerRepoReleases
     *
     * 创建仓库Release
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $tagName Tag 名称, 提倡以v字母为前缀做为Release名称，例如v1.0或者v2.3.4 (required)
     * @param  string $name Release 名称 (required)
     * @param  string $body Release 描述 (required)
     * @param  string $targetCommitish 分支名称或者commit SHA, 默认是当前默认分支 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  bool $prerelease 是否为预览版本。默认: false（非预览版本） (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Release
     */
    public function postV5ReposOwnerRepoReleases($owner, $repo, $tagName, $name, $body, $targetCommitish, $accessToken = null, $prerelease = null)
    {
        list($response) = $this->postV5ReposOwnerRepoReleasesWithHttpInfo($owner, $repo, $tagName, $name, $body, $targetCommitish, $accessToken, $prerelease);
        return $response;
    }

    /**
     * Operation postV5ReposOwnerRepoReleasesWithHttpInfo
     *
     * 创建仓库Release
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $tagName Tag 名称, 提倡以v字母为前缀做为Release名称，例如v1.0或者v2.3.4 (required)
     * @param  string $name Release 名称 (required)
     * @param  string $body Release 描述 (required)
     * @param  string $targetCommitish 分支名称或者commit SHA, 默认是当前默认分支 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  bool $prerelease 是否为预览版本。默认: false（非预览版本） (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Release, HTTP status code, HTTP response headers (array of strings)
     */
    public function postV5ReposOwnerRepoReleasesWithHttpInfo($owner, $repo, $tagName, $name, $body, $targetCommitish, $accessToken = null, $prerelease = null)
    {
        $returnType = '\Gitee\Model\Release';
        $request = $this->postV5ReposOwnerRepoReleasesRequest($owner, $repo, $tagName, $name, $body, $targetCommitish, $accessToken, $prerelease);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Release',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postV5ReposOwnerRepoReleasesAsync
     *
     * 创建仓库Release
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $tagName Tag 名称, 提倡以v字母为前缀做为Release名称，例如v1.0或者v2.3.4 (required)
     * @param  string $name Release 名称 (required)
     * @param  string $body Release 描述 (required)
     * @param  string $targetCommitish 分支名称或者commit SHA, 默认是当前默认分支 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  bool $prerelease 是否为预览版本。默认: false（非预览版本） (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5ReposOwnerRepoReleasesAsync($owner, $repo, $tagName, $name, $body, $targetCommitish, $accessToken = null, $prerelease = null)
    {
        return $this->postV5ReposOwnerRepoReleasesAsyncWithHttpInfo($owner, $repo, $tagName, $name, $body, $targetCommitish, $accessToken, $prerelease)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postV5ReposOwnerRepoReleasesAsyncWithHttpInfo
     *
     * 创建仓库Release
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $tagName Tag 名称, 提倡以v字母为前缀做为Release名称，例如v1.0或者v2.3.4 (required)
     * @param  string $name Release 名称 (required)
     * @param  string $body Release 描述 (required)
     * @param  string $targetCommitish 分支名称或者commit SHA, 默认是当前默认分支 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  bool $prerelease 是否为预览版本。默认: false（非预览版本） (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5ReposOwnerRepoReleasesAsyncWithHttpInfo($owner, $repo, $tagName, $name, $body, $targetCommitish, $accessToken = null, $prerelease = null)
    {
        $returnType = '\Gitee\Model\Release';
        $request = $this->postV5ReposOwnerRepoReleasesRequest($owner, $repo, $tagName, $name, $body, $targetCommitish, $accessToken, $prerelease);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postV5ReposOwnerRepoReleases'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $tagName Tag 名称, 提倡以v字母为前缀做为Release名称，例如v1.0或者v2.3.4 (required)
     * @param  string $name Release 名称 (required)
     * @param  string $body Release 描述 (required)
     * @param  string $targetCommitish 分支名称或者commit SHA, 默认是当前默认分支 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  bool $prerelease 是否为预览版本。默认: false（非预览版本） (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postV5ReposOwnerRepoReleasesRequest($owner, $repo, $tagName, $name, $body, $targetCommitish, $accessToken = null, $prerelease = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling postV5ReposOwnerRepoReleases'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling postV5ReposOwnerRepoReleases'
            );
        }
        // verify the required parameter 'tagName' is set
        if ($tagName === null || (is_array($tagName) && count($tagName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tagName when calling postV5ReposOwnerRepoReleases'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postV5ReposOwnerRepoReleases'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postV5ReposOwnerRepoReleases'
            );
        }
        // verify the required parameter 'targetCommitish' is set
        if ($targetCommitish === null || (is_array($targetCommitish) && count($targetCommitish) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $targetCommitish when calling postV5ReposOwnerRepoReleases'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/releases';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // form params
        if ($tagName !== null) {
            $formParams['tag_name'] = ObjectSerializer::toFormValue($tagName);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($body !== null) {
            $formParams['body'] = ObjectSerializer::toFormValue($body);
        }
        // form params
        if ($prerelease !== null) {
            $formParams['prerelease'] = ObjectSerializer::toFormValue($prerelease);
        }
        // form params
        if ($targetCommitish !== null) {
            $formParams['target_commitish'] = ObjectSerializer::toFormValue($targetCommitish);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postV5ReposOwnerRepoReleasesReleaseIdAttachFiles
     *
     * 上传附件到仓库指定 Release
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $releaseId 发行版本的ID (required)
     * @param  \SplFileObject $file 上传的文件 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\AttachFile
     */
    public function postV5ReposOwnerRepoReleasesReleaseIdAttachFiles($owner, $repo, $releaseId, $file, $accessToken = null)
    {
        list($response) = $this->postV5ReposOwnerRepoReleasesReleaseIdAttachFilesWithHttpInfo($owner, $repo, $releaseId, $file, $accessToken);
        return $response;
    }

    /**
     * Operation postV5ReposOwnerRepoReleasesReleaseIdAttachFilesWithHttpInfo
     *
     * 上传附件到仓库指定 Release
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $releaseId 发行版本的ID (required)
     * @param  \SplFileObject $file 上传的文件 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\AttachFile, HTTP status code, HTTP response headers (array of strings)
     */
    public function postV5ReposOwnerRepoReleasesReleaseIdAttachFilesWithHttpInfo($owner, $repo, $releaseId, $file, $accessToken = null)
    {
        $returnType = '\Gitee\Model\AttachFile';
        $request = $this->postV5ReposOwnerRepoReleasesReleaseIdAttachFilesRequest($owner, $repo, $releaseId, $file, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\AttachFile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postV5ReposOwnerRepoReleasesReleaseIdAttachFilesAsync
     *
     * 上传附件到仓库指定 Release
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $releaseId 发行版本的ID (required)
     * @param  \SplFileObject $file 上传的文件 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5ReposOwnerRepoReleasesReleaseIdAttachFilesAsync($owner, $repo, $releaseId, $file, $accessToken = null)
    {
        return $this->postV5ReposOwnerRepoReleasesReleaseIdAttachFilesAsyncWithHttpInfo($owner, $repo, $releaseId, $file, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postV5ReposOwnerRepoReleasesReleaseIdAttachFilesAsyncWithHttpInfo
     *
     * 上传附件到仓库指定 Release
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $releaseId 发行版本的ID (required)
     * @param  \SplFileObject $file 上传的文件 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5ReposOwnerRepoReleasesReleaseIdAttachFilesAsyncWithHttpInfo($owner, $repo, $releaseId, $file, $accessToken = null)
    {
        $returnType = '\Gitee\Model\AttachFile';
        $request = $this->postV5ReposOwnerRepoReleasesReleaseIdAttachFilesRequest($owner, $repo, $releaseId, $file, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postV5ReposOwnerRepoReleasesReleaseIdAttachFiles'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $releaseId 发行版本的ID (required)
     * @param  \SplFileObject $file 上传的文件 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postV5ReposOwnerRepoReleasesReleaseIdAttachFilesRequest($owner, $repo, $releaseId, $file, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling postV5ReposOwnerRepoReleasesReleaseIdAttachFiles'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling postV5ReposOwnerRepoReleasesReleaseIdAttachFiles'
            );
        }
        // verify the required parameter 'releaseId' is set
        if ($releaseId === null || (is_array($releaseId) && count($releaseId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $releaseId when calling postV5ReposOwnerRepoReleasesReleaseIdAttachFiles'
            );
        }
        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling postV5ReposOwnerRepoReleasesReleaseIdAttachFiles'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/releases/{release_id}/attach_files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($releaseId !== null) {
            $resourcePath = str_replace(
                '{' . 'release_id' . '}',
                ObjectSerializer::toPathValue($releaseId),
                $resourcePath
            );
        }

        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postV5ReposOwnerRepoTags
     *
     * 创建一个仓库的 Tag
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $refs 起点名称, 默认：master (required)
     * @param  string $tagName 新创建的标签名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $tagMessage Tag 描述, 默认为空 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Tag
     */
    public function postV5ReposOwnerRepoTags($owner, $repo, $refs, $tagName, $accessToken = null, $tagMessage = null)
    {
        list($response) = $this->postV5ReposOwnerRepoTagsWithHttpInfo($owner, $repo, $refs, $tagName, $accessToken, $tagMessage);
        return $response;
    }

    /**
     * Operation postV5ReposOwnerRepoTagsWithHttpInfo
     *
     * 创建一个仓库的 Tag
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $refs 起点名称, 默认：master (required)
     * @param  string $tagName 新创建的标签名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $tagMessage Tag 描述, 默认为空 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Tag, HTTP status code, HTTP response headers (array of strings)
     */
    public function postV5ReposOwnerRepoTagsWithHttpInfo($owner, $repo, $refs, $tagName, $accessToken = null, $tagMessage = null)
    {
        $returnType = '\Gitee\Model\Tag';
        $request = $this->postV5ReposOwnerRepoTagsRequest($owner, $repo, $refs, $tagName, $accessToken, $tagMessage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Tag',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postV5ReposOwnerRepoTagsAsync
     *
     * 创建一个仓库的 Tag
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $refs 起点名称, 默认：master (required)
     * @param  string $tagName 新创建的标签名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $tagMessage Tag 描述, 默认为空 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5ReposOwnerRepoTagsAsync($owner, $repo, $refs, $tagName, $accessToken = null, $tagMessage = null)
    {
        return $this->postV5ReposOwnerRepoTagsAsyncWithHttpInfo($owner, $repo, $refs, $tagName, $accessToken, $tagMessage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postV5ReposOwnerRepoTagsAsyncWithHttpInfo
     *
     * 创建一个仓库的 Tag
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $refs 起点名称, 默认：master (required)
     * @param  string $tagName 新创建的标签名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $tagMessage Tag 描述, 默认为空 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5ReposOwnerRepoTagsAsyncWithHttpInfo($owner, $repo, $refs, $tagName, $accessToken = null, $tagMessage = null)
    {
        $returnType = '\Gitee\Model\Tag';
        $request = $this->postV5ReposOwnerRepoTagsRequest($owner, $repo, $refs, $tagName, $accessToken, $tagMessage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postV5ReposOwnerRepoTags'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $refs 起点名称, 默认：master (required)
     * @param  string $tagName 新创建的标签名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $tagMessage Tag 描述, 默认为空 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postV5ReposOwnerRepoTagsRequest($owner, $repo, $refs, $tagName, $accessToken = null, $tagMessage = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling postV5ReposOwnerRepoTags'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling postV5ReposOwnerRepoTags'
            );
        }
        // verify the required parameter 'refs' is set
        if ($refs === null || (is_array($refs) && count($refs) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $refs when calling postV5ReposOwnerRepoTags'
            );
        }
        // verify the required parameter 'tagName' is set
        if ($tagName === null || (is_array($tagName) && count($tagName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tagName when calling postV5ReposOwnerRepoTags'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // form params
        if ($refs !== null) {
            $formParams['refs'] = ObjectSerializer::toFormValue($refs);
        }
        // form params
        if ($tagName !== null) {
            $formParams['tag_name'] = ObjectSerializer::toFormValue($tagName);
        }
        // form params
        if ($tagMessage !== null) {
            $formParams['tag_message'] = ObjectSerializer::toFormValue($tagMessage);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postV5ReposOwnerRepoTrafficData
     *
     * 获取最近30天的七日以内访问量
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $startDay 访问量的开始时间，默认今天，格式：yyyy-MM-dd (optional)
     * @param  string $endDay 访问量的结束时间，默认七天前，格式：yyyy-MM-dd (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\ProjectTrafficData
     */
    public function postV5ReposOwnerRepoTrafficData($owner, $repo, $accessToken = null, $startDay = null, $endDay = null)
    {
        list($response) = $this->postV5ReposOwnerRepoTrafficDataWithHttpInfo($owner, $repo, $accessToken, $startDay, $endDay);
        return $response;
    }

    /**
     * Operation postV5ReposOwnerRepoTrafficDataWithHttpInfo
     *
     * 获取最近30天的七日以内访问量
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $startDay 访问量的开始时间，默认今天，格式：yyyy-MM-dd (optional)
     * @param  string $endDay 访问量的结束时间，默认七天前，格式：yyyy-MM-dd (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\ProjectTrafficData, HTTP status code, HTTP response headers (array of strings)
     */
    public function postV5ReposOwnerRepoTrafficDataWithHttpInfo($owner, $repo, $accessToken = null, $startDay = null, $endDay = null)
    {
        $returnType = '\Gitee\Model\ProjectTrafficData';
        $request = $this->postV5ReposOwnerRepoTrafficDataRequest($owner, $repo, $accessToken, $startDay, $endDay);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\ProjectTrafficData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postV5ReposOwnerRepoTrafficDataAsync
     *
     * 获取最近30天的七日以内访问量
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $startDay 访问量的开始时间，默认今天，格式：yyyy-MM-dd (optional)
     * @param  string $endDay 访问量的结束时间，默认七天前，格式：yyyy-MM-dd (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5ReposOwnerRepoTrafficDataAsync($owner, $repo, $accessToken = null, $startDay = null, $endDay = null)
    {
        return $this->postV5ReposOwnerRepoTrafficDataAsyncWithHttpInfo($owner, $repo, $accessToken, $startDay, $endDay)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postV5ReposOwnerRepoTrafficDataAsyncWithHttpInfo
     *
     * 获取最近30天的七日以内访问量
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $startDay 访问量的开始时间，默认今天，格式：yyyy-MM-dd (optional)
     * @param  string $endDay 访问量的结束时间，默认七天前，格式：yyyy-MM-dd (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5ReposOwnerRepoTrafficDataAsyncWithHttpInfo($owner, $repo, $accessToken = null, $startDay = null, $endDay = null)
    {
        $returnType = '\Gitee\Model\ProjectTrafficData';
        $request = $this->postV5ReposOwnerRepoTrafficDataRequest($owner, $repo, $accessToken, $startDay, $endDay);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postV5ReposOwnerRepoTrafficData'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $startDay 访问量的开始时间，默认今天，格式：yyyy-MM-dd (optional)
     * @param  string $endDay 访问量的结束时间，默认七天前，格式：yyyy-MM-dd (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postV5ReposOwnerRepoTrafficDataRequest($owner, $repo, $accessToken = null, $startDay = null, $endDay = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling postV5ReposOwnerRepoTrafficData'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling postV5ReposOwnerRepoTrafficData'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/traffic-data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // form params
        if ($startDay !== null) {
            $formParams['start_day'] = ObjectSerializer::toFormValue($startDay);
        }
        // form params
        if ($endDay !== null) {
            $formParams['end_day'] = ObjectSerializer::toFormValue($endDay);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postV5UserRepos
     *
     * 创建一个仓库
     *
     * @param  string $name 仓库名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $description 仓库描述 (optional)
     * @param  string $homepage 主页(eg: https://gitee.com) (optional)
     * @param  bool $hasIssues 允许提Issue与否。默认: 允许(true) (optional, default to true)
     * @param  bool $hasWiki 提供Wiki与否。默认: 提供(true) (optional, default to true)
     * @param  bool $canComment 允许用户对仓库进行评论。默认： 允许(true) (optional, default to true)
     * @param  bool $autoInit 值为true时则会用README初始化仓库。默认: 不初始化(false) (optional)
     * @param  string $gitignoreTemplate Git Ignore模版 (optional)
     * @param  string $licenseTemplate License模版 (optional)
     * @param  string $path 仓库路径 (optional)
     * @param  bool $private 目前仅支持私有 (optional, default to true)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Project
     */
    public function postV5UserRepos($name, $accessToken = null, $description = null, $homepage = null, $hasIssues = 'true', $hasWiki = 'true', $canComment = 'true', $autoInit = null, $gitignoreTemplate = null, $licenseTemplate = null, $path = null, $private = 'true')
    {
        list($response) = $this->postV5UserReposWithHttpInfo($name, $accessToken, $description, $homepage, $hasIssues, $hasWiki, $canComment, $autoInit, $gitignoreTemplate, $licenseTemplate, $path, $private);
        return $response;
    }

    /**
     * Operation postV5UserReposWithHttpInfo
     *
     * 创建一个仓库
     *
     * @param  string $name 仓库名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $description 仓库描述 (optional)
     * @param  string $homepage 主页(eg: https://gitee.com) (optional)
     * @param  bool $hasIssues 允许提Issue与否。默认: 允许(true) (optional, default to true)
     * @param  bool $hasWiki 提供Wiki与否。默认: 提供(true) (optional, default to true)
     * @param  bool $canComment 允许用户对仓库进行评论。默认： 允许(true) (optional, default to true)
     * @param  bool $autoInit 值为true时则会用README初始化仓库。默认: 不初始化(false) (optional)
     * @param  string $gitignoreTemplate Git Ignore模版 (optional)
     * @param  string $licenseTemplate License模版 (optional)
     * @param  string $path 仓库路径 (optional)
     * @param  bool $private 目前仅支持私有 (optional, default to true)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Project, HTTP status code, HTTP response headers (array of strings)
     */
    public function postV5UserReposWithHttpInfo($name, $accessToken = null, $description = null, $homepage = null, $hasIssues = 'true', $hasWiki = 'true', $canComment = 'true', $autoInit = null, $gitignoreTemplate = null, $licenseTemplate = null, $path = null, $private = 'true')
    {
        $returnType = '\Gitee\Model\Project';
        $request = $this->postV5UserReposRequest($name, $accessToken, $description, $homepage, $hasIssues, $hasWiki, $canComment, $autoInit, $gitignoreTemplate, $licenseTemplate, $path, $private);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Project',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postV5UserReposAsync
     *
     * 创建一个仓库
     *
     * @param  string $name 仓库名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $description 仓库描述 (optional)
     * @param  string $homepage 主页(eg: https://gitee.com) (optional)
     * @param  bool $hasIssues 允许提Issue与否。默认: 允许(true) (optional, default to true)
     * @param  bool $hasWiki 提供Wiki与否。默认: 提供(true) (optional, default to true)
     * @param  bool $canComment 允许用户对仓库进行评论。默认： 允许(true) (optional, default to true)
     * @param  bool $autoInit 值为true时则会用README初始化仓库。默认: 不初始化(false) (optional)
     * @param  string $gitignoreTemplate Git Ignore模版 (optional)
     * @param  string $licenseTemplate License模版 (optional)
     * @param  string $path 仓库路径 (optional)
     * @param  bool $private 目前仅支持私有 (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5UserReposAsync($name, $accessToken = null, $description = null, $homepage = null, $hasIssues = 'true', $hasWiki = 'true', $canComment = 'true', $autoInit = null, $gitignoreTemplate = null, $licenseTemplate = null, $path = null, $private = 'true')
    {
        return $this->postV5UserReposAsyncWithHttpInfo($name, $accessToken, $description, $homepage, $hasIssues, $hasWiki, $canComment, $autoInit, $gitignoreTemplate, $licenseTemplate, $path, $private)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postV5UserReposAsyncWithHttpInfo
     *
     * 创建一个仓库
     *
     * @param  string $name 仓库名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $description 仓库描述 (optional)
     * @param  string $homepage 主页(eg: https://gitee.com) (optional)
     * @param  bool $hasIssues 允许提Issue与否。默认: 允许(true) (optional, default to true)
     * @param  bool $hasWiki 提供Wiki与否。默认: 提供(true) (optional, default to true)
     * @param  bool $canComment 允许用户对仓库进行评论。默认： 允许(true) (optional, default to true)
     * @param  bool $autoInit 值为true时则会用README初始化仓库。默认: 不初始化(false) (optional)
     * @param  string $gitignoreTemplate Git Ignore模版 (optional)
     * @param  string $licenseTemplate License模版 (optional)
     * @param  string $path 仓库路径 (optional)
     * @param  bool $private 目前仅支持私有 (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postV5UserReposAsyncWithHttpInfo($name, $accessToken = null, $description = null, $homepage = null, $hasIssues = 'true', $hasWiki = 'true', $canComment = 'true', $autoInit = null, $gitignoreTemplate = null, $licenseTemplate = null, $path = null, $private = 'true')
    {
        $returnType = '\Gitee\Model\Project';
        $request = $this->postV5UserReposRequest($name, $accessToken, $description, $homepage, $hasIssues, $hasWiki, $canComment, $autoInit, $gitignoreTemplate, $licenseTemplate, $path, $private);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postV5UserRepos'
     *
     * @param  string $name 仓库名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $description 仓库描述 (optional)
     * @param  string $homepage 主页(eg: https://gitee.com) (optional)
     * @param  bool $hasIssues 允许提Issue与否。默认: 允许(true) (optional, default to true)
     * @param  bool $hasWiki 提供Wiki与否。默认: 提供(true) (optional, default to true)
     * @param  bool $canComment 允许用户对仓库进行评论。默认： 允许(true) (optional, default to true)
     * @param  bool $autoInit 值为true时则会用README初始化仓库。默认: 不初始化(false) (optional)
     * @param  string $gitignoreTemplate Git Ignore模版 (optional)
     * @param  string $licenseTemplate License模版 (optional)
     * @param  string $path 仓库路径 (optional)
     * @param  bool $private 目前仅支持私有 (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postV5UserReposRequest($name, $accessToken = null, $description = null, $homepage = null, $hasIssues = 'true', $hasWiki = 'true', $canComment = 'true', $autoInit = null, $gitignoreTemplate = null, $licenseTemplate = null, $path = null, $private = 'true')
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postV5UserRepos'
            );
        }

        $resourcePath = '/v5/user/repos';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($description !== null) {
            $formParams['description'] = ObjectSerializer::toFormValue($description);
        }
        // form params
        if ($homepage !== null) {
            $formParams['homepage'] = ObjectSerializer::toFormValue($homepage);
        }
        // form params
        if ($hasIssues !== null) {
            $formParams['has_issues'] = ObjectSerializer::toFormValue($hasIssues);
        }
        // form params
        if ($hasWiki !== null) {
            $formParams['has_wiki'] = ObjectSerializer::toFormValue($hasWiki);
        }
        // form params
        if ($canComment !== null) {
            $formParams['can_comment'] = ObjectSerializer::toFormValue($canComment);
        }
        // form params
        if ($autoInit !== null) {
            $formParams['auto_init'] = ObjectSerializer::toFormValue($autoInit);
        }
        // form params
        if ($gitignoreTemplate !== null) {
            $formParams['gitignore_template'] = ObjectSerializer::toFormValue($gitignoreTemplate);
        }
        // form params
        if ($licenseTemplate !== null) {
            $formParams['license_template'] = ObjectSerializer::toFormValue($licenseTemplate);
        }
        // form params
        if ($path !== null) {
            $formParams['path'] = ObjectSerializer::toFormValue($path);
        }
        // form params
        if ($private !== null) {
            $formParams['private'] = ObjectSerializer::toFormValue($private);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putV5ReposOwnerRepoBranchesBranchProtection
     *
     * 设置分支保护
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $branch 分支名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\CompleteBranch
     */
    public function putV5ReposOwnerRepoBranchesBranchProtection($owner, $repo, $branch, $accessToken = null)
    {
        list($response) = $this->putV5ReposOwnerRepoBranchesBranchProtectionWithHttpInfo($owner, $repo, $branch, $accessToken);
        return $response;
    }

    /**
     * Operation putV5ReposOwnerRepoBranchesBranchProtectionWithHttpInfo
     *
     * 设置分支保护
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $branch 分支名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\CompleteBranch, HTTP status code, HTTP response headers (array of strings)
     */
    public function putV5ReposOwnerRepoBranchesBranchProtectionWithHttpInfo($owner, $repo, $branch, $accessToken = null)
    {
        $returnType = '\Gitee\Model\CompleteBranch';
        $request = $this->putV5ReposOwnerRepoBranchesBranchProtectionRequest($owner, $repo, $branch, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\CompleteBranch',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putV5ReposOwnerRepoBranchesBranchProtectionAsync
     *
     * 设置分支保护
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $branch 分支名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putV5ReposOwnerRepoBranchesBranchProtectionAsync($owner, $repo, $branch, $accessToken = null)
    {
        return $this->putV5ReposOwnerRepoBranchesBranchProtectionAsyncWithHttpInfo($owner, $repo, $branch, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putV5ReposOwnerRepoBranchesBranchProtectionAsyncWithHttpInfo
     *
     * 设置分支保护
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $branch 分支名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putV5ReposOwnerRepoBranchesBranchProtectionAsyncWithHttpInfo($owner, $repo, $branch, $accessToken = null)
    {
        $returnType = '\Gitee\Model\CompleteBranch';
        $request = $this->putV5ReposOwnerRepoBranchesBranchProtectionRequest($owner, $repo, $branch, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putV5ReposOwnerRepoBranchesBranchProtection'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $branch 分支名称 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putV5ReposOwnerRepoBranchesBranchProtectionRequest($owner, $repo, $branch, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling putV5ReposOwnerRepoBranchesBranchProtection'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling putV5ReposOwnerRepoBranchesBranchProtection'
            );
        }
        // verify the required parameter 'branch' is set
        if ($branch === null || (is_array($branch) && count($branch) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $branch when calling putV5ReposOwnerRepoBranchesBranchProtection'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/branches/{branch}/protection';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($branch !== null) {
            $resourcePath = str_replace(
                '{' . 'branch' . '}',
                ObjectSerializer::toPathValue($branch),
                $resourcePath
            );
        }

        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putV5ReposOwnerRepoBranchesSettingNew
     *
     * 新建保护分支规则
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $wildcard 分支/通配符 (required)
     * @param  string $pusher 可推送代码成员。developer：仓库管理员和开发者；admin：仓库管理员；none：禁止任何人合并; 用户：个人的地址 path（多个用户用 &#39;;&#39; 隔开） (required)
     * @param  string $merger 可合并 Pull Request 成员。developer：仓库管理员和开发者；admin：仓库管理员；none：禁止任何人合并; 用户：个人的地址 path（多个用户用 &#39;;&#39; 隔开） (required)
     * @param  string $mode 模式。standard: 标准模式, review: 评审模式 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string[] $escapseProtectBranchList 不受规则影响的分支列表，以英文逗号分隔，形如：[&#39;a&#39;, &#39;b&#39;] (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\ProtectionRule
     */
    public function putV5ReposOwnerRepoBranchesSettingNew($owner, $repo, $wildcard, $pusher, $merger, $mode, $accessToken = null, $escapseProtectBranchList = null)
    {
        list($response) = $this->putV5ReposOwnerRepoBranchesSettingNewWithHttpInfo($owner, $repo, $wildcard, $pusher, $merger, $mode, $accessToken, $escapseProtectBranchList);
        return $response;
    }

    /**
     * Operation putV5ReposOwnerRepoBranchesSettingNewWithHttpInfo
     *
     * 新建保护分支规则
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $wildcard 分支/通配符 (required)
     * @param  string $pusher 可推送代码成员。developer：仓库管理员和开发者；admin：仓库管理员；none：禁止任何人合并; 用户：个人的地址 path（多个用户用 &#39;;&#39; 隔开） (required)
     * @param  string $merger 可合并 Pull Request 成员。developer：仓库管理员和开发者；admin：仓库管理员；none：禁止任何人合并; 用户：个人的地址 path（多个用户用 &#39;;&#39; 隔开） (required)
     * @param  string $mode 模式。standard: 标准模式, review: 评审模式 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string[] $escapseProtectBranchList 不受规则影响的分支列表，以英文逗号分隔，形如：[&#39;a&#39;, &#39;b&#39;] (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\ProtectionRule, HTTP status code, HTTP response headers (array of strings)
     */
    public function putV5ReposOwnerRepoBranchesSettingNewWithHttpInfo($owner, $repo, $wildcard, $pusher, $merger, $mode, $accessToken = null, $escapseProtectBranchList = null)
    {
        $returnType = '\Gitee\Model\ProtectionRule';
        $request = $this->putV5ReposOwnerRepoBranchesSettingNewRequest($owner, $repo, $wildcard, $pusher, $merger, $mode, $accessToken, $escapseProtectBranchList);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\ProtectionRule',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putV5ReposOwnerRepoBranchesSettingNewAsync
     *
     * 新建保护分支规则
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $wildcard 分支/通配符 (required)
     * @param  string $pusher 可推送代码成员。developer：仓库管理员和开发者；admin：仓库管理员；none：禁止任何人合并; 用户：个人的地址 path（多个用户用 &#39;;&#39; 隔开） (required)
     * @param  string $merger 可合并 Pull Request 成员。developer：仓库管理员和开发者；admin：仓库管理员；none：禁止任何人合并; 用户：个人的地址 path（多个用户用 &#39;;&#39; 隔开） (required)
     * @param  string $mode 模式。standard: 标准模式, review: 评审模式 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string[] $escapseProtectBranchList 不受规则影响的分支列表，以英文逗号分隔，形如：[&#39;a&#39;, &#39;b&#39;] (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putV5ReposOwnerRepoBranchesSettingNewAsync($owner, $repo, $wildcard, $pusher, $merger, $mode, $accessToken = null, $escapseProtectBranchList = null)
    {
        return $this->putV5ReposOwnerRepoBranchesSettingNewAsyncWithHttpInfo($owner, $repo, $wildcard, $pusher, $merger, $mode, $accessToken, $escapseProtectBranchList)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putV5ReposOwnerRepoBranchesSettingNewAsyncWithHttpInfo
     *
     * 新建保护分支规则
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $wildcard 分支/通配符 (required)
     * @param  string $pusher 可推送代码成员。developer：仓库管理员和开发者；admin：仓库管理员；none：禁止任何人合并; 用户：个人的地址 path（多个用户用 &#39;;&#39; 隔开） (required)
     * @param  string $merger 可合并 Pull Request 成员。developer：仓库管理员和开发者；admin：仓库管理员；none：禁止任何人合并; 用户：个人的地址 path（多个用户用 &#39;;&#39; 隔开） (required)
     * @param  string $mode 模式。standard: 标准模式, review: 评审模式 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string[] $escapseProtectBranchList 不受规则影响的分支列表，以英文逗号分隔，形如：[&#39;a&#39;, &#39;b&#39;] (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putV5ReposOwnerRepoBranchesSettingNewAsyncWithHttpInfo($owner, $repo, $wildcard, $pusher, $merger, $mode, $accessToken = null, $escapseProtectBranchList = null)
    {
        $returnType = '\Gitee\Model\ProtectionRule';
        $request = $this->putV5ReposOwnerRepoBranchesSettingNewRequest($owner, $repo, $wildcard, $pusher, $merger, $mode, $accessToken, $escapseProtectBranchList);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putV5ReposOwnerRepoBranchesSettingNew'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $wildcard 分支/通配符 (required)
     * @param  string $pusher 可推送代码成员。developer：仓库管理员和开发者；admin：仓库管理员；none：禁止任何人合并; 用户：个人的地址 path（多个用户用 &#39;;&#39; 隔开） (required)
     * @param  string $merger 可合并 Pull Request 成员。developer：仓库管理员和开发者；admin：仓库管理员；none：禁止任何人合并; 用户：个人的地址 path（多个用户用 &#39;;&#39; 隔开） (required)
     * @param  string $mode 模式。standard: 标准模式, review: 评审模式 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string[] $escapseProtectBranchList 不受规则影响的分支列表，以英文逗号分隔，形如：[&#39;a&#39;, &#39;b&#39;] (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putV5ReposOwnerRepoBranchesSettingNewRequest($owner, $repo, $wildcard, $pusher, $merger, $mode, $accessToken = null, $escapseProtectBranchList = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling putV5ReposOwnerRepoBranchesSettingNew'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling putV5ReposOwnerRepoBranchesSettingNew'
            );
        }
        // verify the required parameter 'wildcard' is set
        if ($wildcard === null || (is_array($wildcard) && count($wildcard) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wildcard when calling putV5ReposOwnerRepoBranchesSettingNew'
            );
        }
        // verify the required parameter 'pusher' is set
        if ($pusher === null || (is_array($pusher) && count($pusher) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pusher when calling putV5ReposOwnerRepoBranchesSettingNew'
            );
        }
        // verify the required parameter 'merger' is set
        if ($merger === null || (is_array($merger) && count($merger) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merger when calling putV5ReposOwnerRepoBranchesSettingNew'
            );
        }
        // verify the required parameter 'mode' is set
        if ($mode === null || (is_array($mode) && count($mode) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mode when calling putV5ReposOwnerRepoBranchesSettingNew'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/branches/setting/new';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // form params
        if ($wildcard !== null) {
            $formParams['wildcard'] = ObjectSerializer::toFormValue($wildcard);
        }
        // form params
        if ($pusher !== null) {
            $formParams['pusher'] = ObjectSerializer::toFormValue($pusher);
        }
        // form params
        if ($merger !== null) {
            $formParams['merger'] = ObjectSerializer::toFormValue($merger);
        }
        // form params
        if ($mode !== null) {
            $formParams['mode'] = ObjectSerializer::toFormValue($mode);
        }
        // form params
        if ($escapseProtectBranchList !== null) {
            $formParams['escapse_protect_branch_list'] = ObjectSerializer::toFormValue($escapseProtectBranchList);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putV5ReposOwnerRepoBranchesWildcardSetting
     *
     * 更新保护分支规则
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $wildcard 分支/通配符 (required)
     * @param  string $pusher 可推送代码成员。developer：仓库管理员和开发者；admin：仓库管理员；none：禁止任何人合并; 用户：个人的地址 path（多个用户用 &#39;;&#39; 隔开） (required)
     * @param  string $merger 可合并 Pull Request 成员。developer：仓库管理员和开发者；admin：仓库管理员；none：禁止任何人合并; 用户：个人的地址 path（多个用户用 &#39;;&#39; 隔开） (required)
     * @param  string $mode 模式。standard: 标准模式, review: 评审模式 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $newWildcard 新分支/通配符(为空不修改) (optional)
     * @param  string[] $escapseProtectBranchList 不受规则影响的分支列表，以英文逗号分隔，形如：[&#39;a&#39;, &#39;b&#39;] (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\ProtectionRule
     */
    public function putV5ReposOwnerRepoBranchesWildcardSetting($owner, $repo, $wildcard, $pusher, $merger, $mode, $accessToken = null, $newWildcard = null, $escapseProtectBranchList = null)
    {
        list($response) = $this->putV5ReposOwnerRepoBranchesWildcardSettingWithHttpInfo($owner, $repo, $wildcard, $pusher, $merger, $mode, $accessToken, $newWildcard, $escapseProtectBranchList);
        return $response;
    }

    /**
     * Operation putV5ReposOwnerRepoBranchesWildcardSettingWithHttpInfo
     *
     * 更新保护分支规则
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $wildcard 分支/通配符 (required)
     * @param  string $pusher 可推送代码成员。developer：仓库管理员和开发者；admin：仓库管理员；none：禁止任何人合并; 用户：个人的地址 path（多个用户用 &#39;;&#39; 隔开） (required)
     * @param  string $merger 可合并 Pull Request 成员。developer：仓库管理员和开发者；admin：仓库管理员；none：禁止任何人合并; 用户：个人的地址 path（多个用户用 &#39;;&#39; 隔开） (required)
     * @param  string $mode 模式。standard: 标准模式, review: 评审模式 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $newWildcard 新分支/通配符(为空不修改) (optional)
     * @param  string[] $escapseProtectBranchList 不受规则影响的分支列表，以英文逗号分隔，形如：[&#39;a&#39;, &#39;b&#39;] (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\ProtectionRule, HTTP status code, HTTP response headers (array of strings)
     */
    public function putV5ReposOwnerRepoBranchesWildcardSettingWithHttpInfo($owner, $repo, $wildcard, $pusher, $merger, $mode, $accessToken = null, $newWildcard = null, $escapseProtectBranchList = null)
    {
        $returnType = '\Gitee\Model\ProtectionRule';
        $request = $this->putV5ReposOwnerRepoBranchesWildcardSettingRequest($owner, $repo, $wildcard, $pusher, $merger, $mode, $accessToken, $newWildcard, $escapseProtectBranchList);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\ProtectionRule',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putV5ReposOwnerRepoBranchesWildcardSettingAsync
     *
     * 更新保护分支规则
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $wildcard 分支/通配符 (required)
     * @param  string $pusher 可推送代码成员。developer：仓库管理员和开发者；admin：仓库管理员；none：禁止任何人合并; 用户：个人的地址 path（多个用户用 &#39;;&#39; 隔开） (required)
     * @param  string $merger 可合并 Pull Request 成员。developer：仓库管理员和开发者；admin：仓库管理员；none：禁止任何人合并; 用户：个人的地址 path（多个用户用 &#39;;&#39; 隔开） (required)
     * @param  string $mode 模式。standard: 标准模式, review: 评审模式 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $newWildcard 新分支/通配符(为空不修改) (optional)
     * @param  string[] $escapseProtectBranchList 不受规则影响的分支列表，以英文逗号分隔，形如：[&#39;a&#39;, &#39;b&#39;] (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putV5ReposOwnerRepoBranchesWildcardSettingAsync($owner, $repo, $wildcard, $pusher, $merger, $mode, $accessToken = null, $newWildcard = null, $escapseProtectBranchList = null)
    {
        return $this->putV5ReposOwnerRepoBranchesWildcardSettingAsyncWithHttpInfo($owner, $repo, $wildcard, $pusher, $merger, $mode, $accessToken, $newWildcard, $escapseProtectBranchList)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putV5ReposOwnerRepoBranchesWildcardSettingAsyncWithHttpInfo
     *
     * 更新保护分支规则
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $wildcard 分支/通配符 (required)
     * @param  string $pusher 可推送代码成员。developer：仓库管理员和开发者；admin：仓库管理员；none：禁止任何人合并; 用户：个人的地址 path（多个用户用 &#39;;&#39; 隔开） (required)
     * @param  string $merger 可合并 Pull Request 成员。developer：仓库管理员和开发者；admin：仓库管理员；none：禁止任何人合并; 用户：个人的地址 path（多个用户用 &#39;;&#39; 隔开） (required)
     * @param  string $mode 模式。standard: 标准模式, review: 评审模式 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $newWildcard 新分支/通配符(为空不修改) (optional)
     * @param  string[] $escapseProtectBranchList 不受规则影响的分支列表，以英文逗号分隔，形如：[&#39;a&#39;, &#39;b&#39;] (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putV5ReposOwnerRepoBranchesWildcardSettingAsyncWithHttpInfo($owner, $repo, $wildcard, $pusher, $merger, $mode, $accessToken = null, $newWildcard = null, $escapseProtectBranchList = null)
    {
        $returnType = '\Gitee\Model\ProtectionRule';
        $request = $this->putV5ReposOwnerRepoBranchesWildcardSettingRequest($owner, $repo, $wildcard, $pusher, $merger, $mode, $accessToken, $newWildcard, $escapseProtectBranchList);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putV5ReposOwnerRepoBranchesWildcardSetting'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $wildcard 分支/通配符 (required)
     * @param  string $pusher 可推送代码成员。developer：仓库管理员和开发者；admin：仓库管理员；none：禁止任何人合并; 用户：个人的地址 path（多个用户用 &#39;;&#39; 隔开） (required)
     * @param  string $merger 可合并 Pull Request 成员。developer：仓库管理员和开发者；admin：仓库管理员；none：禁止任何人合并; 用户：个人的地址 path（多个用户用 &#39;;&#39; 隔开） (required)
     * @param  string $mode 模式。standard: 标准模式, review: 评审模式 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $newWildcard 新分支/通配符(为空不修改) (optional)
     * @param  string[] $escapseProtectBranchList 不受规则影响的分支列表，以英文逗号分隔，形如：[&#39;a&#39;, &#39;b&#39;] (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putV5ReposOwnerRepoBranchesWildcardSettingRequest($owner, $repo, $wildcard, $pusher, $merger, $mode, $accessToken = null, $newWildcard = null, $escapseProtectBranchList = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling putV5ReposOwnerRepoBranchesWildcardSetting'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling putV5ReposOwnerRepoBranchesWildcardSetting'
            );
        }
        // verify the required parameter 'wildcard' is set
        if ($wildcard === null || (is_array($wildcard) && count($wildcard) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wildcard when calling putV5ReposOwnerRepoBranchesWildcardSetting'
            );
        }
        // verify the required parameter 'pusher' is set
        if ($pusher === null || (is_array($pusher) && count($pusher) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pusher when calling putV5ReposOwnerRepoBranchesWildcardSetting'
            );
        }
        // verify the required parameter 'merger' is set
        if ($merger === null || (is_array($merger) && count($merger) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merger when calling putV5ReposOwnerRepoBranchesWildcardSetting'
            );
        }
        // verify the required parameter 'mode' is set
        if ($mode === null || (is_array($mode) && count($mode) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mode when calling putV5ReposOwnerRepoBranchesWildcardSetting'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/branches/{wildcard}/setting';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($wildcard !== null) {
            $resourcePath = str_replace(
                '{' . 'wildcard' . '}',
                ObjectSerializer::toPathValue($wildcard),
                $resourcePath
            );
        }

        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // form params
        if ($newWildcard !== null) {
            $formParams['new_wildcard'] = ObjectSerializer::toFormValue($newWildcard);
        }
        // form params
        if ($pusher !== null) {
            $formParams['pusher'] = ObjectSerializer::toFormValue($pusher);
        }
        // form params
        if ($merger !== null) {
            $formParams['merger'] = ObjectSerializer::toFormValue($merger);
        }
        // form params
        if ($mode !== null) {
            $formParams['mode'] = ObjectSerializer::toFormValue($mode);
        }
        // form params
        if ($escapseProtectBranchList !== null) {
            $formParams['escapse_protect_branch_list'] = ObjectSerializer::toFormValue($escapseProtectBranchList);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putV5ReposOwnerRepoClear
     *
     * 清空一个仓库
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putV5ReposOwnerRepoClear($owner, $repo, $accessToken = null)
    {
        $this->putV5ReposOwnerRepoClearWithHttpInfo($owner, $repo, $accessToken);
    }

    /**
     * Operation putV5ReposOwnerRepoClearWithHttpInfo
     *
     * 清空一个仓库
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putV5ReposOwnerRepoClearWithHttpInfo($owner, $repo, $accessToken = null)
    {
        $returnType = '';
        $request = $this->putV5ReposOwnerRepoClearRequest($owner, $repo, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putV5ReposOwnerRepoClearAsync
     *
     * 清空一个仓库
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putV5ReposOwnerRepoClearAsync($owner, $repo, $accessToken = null)
    {
        return $this->putV5ReposOwnerRepoClearAsyncWithHttpInfo($owner, $repo, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putV5ReposOwnerRepoClearAsyncWithHttpInfo
     *
     * 清空一个仓库
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putV5ReposOwnerRepoClearAsyncWithHttpInfo($owner, $repo, $accessToken = null)
    {
        $returnType = '';
        $request = $this->putV5ReposOwnerRepoClearRequest($owner, $repo, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putV5ReposOwnerRepoClear'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putV5ReposOwnerRepoClearRequest($owner, $repo, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling putV5ReposOwnerRepoClear'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling putV5ReposOwnerRepoClear'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/clear';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putV5ReposOwnerRepoCollaboratorsUsername
     *
     * 添加仓库成员或更新仓库成员权限
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $username 用户名(username/login) (required)
     * @param  string $permission 成员权限: 拉代码(pull)，推代码(push)，管理员(admin)。默认: push (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\ProjectMember
     */
    public function putV5ReposOwnerRepoCollaboratorsUsername($owner, $repo, $username, $permission, $accessToken = null)
    {
        list($response) = $this->putV5ReposOwnerRepoCollaboratorsUsernameWithHttpInfo($owner, $repo, $username, $permission, $accessToken);
        return $response;
    }

    /**
     * Operation putV5ReposOwnerRepoCollaboratorsUsernameWithHttpInfo
     *
     * 添加仓库成员或更新仓库成员权限
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $username 用户名(username/login) (required)
     * @param  string $permission 成员权限: 拉代码(pull)，推代码(push)，管理员(admin)。默认: push (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\ProjectMember, HTTP status code, HTTP response headers (array of strings)
     */
    public function putV5ReposOwnerRepoCollaboratorsUsernameWithHttpInfo($owner, $repo, $username, $permission, $accessToken = null)
    {
        $returnType = '\Gitee\Model\ProjectMember';
        $request = $this->putV5ReposOwnerRepoCollaboratorsUsernameRequest($owner, $repo, $username, $permission, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\ProjectMember',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putV5ReposOwnerRepoCollaboratorsUsernameAsync
     *
     * 添加仓库成员或更新仓库成员权限
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $username 用户名(username/login) (required)
     * @param  string $permission 成员权限: 拉代码(pull)，推代码(push)，管理员(admin)。默认: push (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putV5ReposOwnerRepoCollaboratorsUsernameAsync($owner, $repo, $username, $permission, $accessToken = null)
    {
        return $this->putV5ReposOwnerRepoCollaboratorsUsernameAsyncWithHttpInfo($owner, $repo, $username, $permission, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putV5ReposOwnerRepoCollaboratorsUsernameAsyncWithHttpInfo
     *
     * 添加仓库成员或更新仓库成员权限
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $username 用户名(username/login) (required)
     * @param  string $permission 成员权限: 拉代码(pull)，推代码(push)，管理员(admin)。默认: push (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putV5ReposOwnerRepoCollaboratorsUsernameAsyncWithHttpInfo($owner, $repo, $username, $permission, $accessToken = null)
    {
        $returnType = '\Gitee\Model\ProjectMember';
        $request = $this->putV5ReposOwnerRepoCollaboratorsUsernameRequest($owner, $repo, $username, $permission, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putV5ReposOwnerRepoCollaboratorsUsername'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $username 用户名(username/login) (required)
     * @param  string $permission 成员权限: 拉代码(pull)，推代码(push)，管理员(admin)。默认: push (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putV5ReposOwnerRepoCollaboratorsUsernameRequest($owner, $repo, $username, $permission, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling putV5ReposOwnerRepoCollaboratorsUsername'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling putV5ReposOwnerRepoCollaboratorsUsername'
            );
        }
        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling putV5ReposOwnerRepoCollaboratorsUsername'
            );
        }
        // verify the required parameter 'permission' is set
        if ($permission === null || (is_array($permission) && count($permission) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $permission when calling putV5ReposOwnerRepoCollaboratorsUsername'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/collaborators/{username}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }

        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // form params
        if ($permission !== null) {
            $formParams['permission'] = ObjectSerializer::toFormValue($permission);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putV5ReposOwnerRepoContentsPath
     *
     * 更新文件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径 (required)
     * @param  string $content 文件内容, 要用 base64 编码 (required)
     * @param  string $sha 文件的 Blob SHA，可通过 [获取仓库具体路径下的内容] API 获取 (required)
     * @param  string $message 提交信息 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $branch 分支名称。默认为仓库对默认分支 (optional)
     * @param  string $committerName Committer的名字，默认为当前用户的名字 (optional)
     * @param  string $committerEmail Committer的邮箱，默认为当前用户的邮箱 (optional)
     * @param  string $authorName Author的名字，默认为当前用户的名字 (optional)
     * @param  string $authorEmail Author的邮箱，默认为当前用户的邮箱 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\CommitContent
     */
    public function putV5ReposOwnerRepoContentsPath($owner, $repo, $path, $content, $sha, $message, $accessToken = null, $branch = null, $committerName = null, $committerEmail = null, $authorName = null, $authorEmail = null)
    {
        list($response) = $this->putV5ReposOwnerRepoContentsPathWithHttpInfo($owner, $repo, $path, $content, $sha, $message, $accessToken, $branch, $committerName, $committerEmail, $authorName, $authorEmail);
        return $response;
    }

    /**
     * Operation putV5ReposOwnerRepoContentsPathWithHttpInfo
     *
     * 更新文件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径 (required)
     * @param  string $content 文件内容, 要用 base64 编码 (required)
     * @param  string $sha 文件的 Blob SHA，可通过 [获取仓库具体路径下的内容] API 获取 (required)
     * @param  string $message 提交信息 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $branch 分支名称。默认为仓库对默认分支 (optional)
     * @param  string $committerName Committer的名字，默认为当前用户的名字 (optional)
     * @param  string $committerEmail Committer的邮箱，默认为当前用户的邮箱 (optional)
     * @param  string $authorName Author的名字，默认为当前用户的名字 (optional)
     * @param  string $authorEmail Author的邮箱，默认为当前用户的邮箱 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\CommitContent, HTTP status code, HTTP response headers (array of strings)
     */
    public function putV5ReposOwnerRepoContentsPathWithHttpInfo($owner, $repo, $path, $content, $sha, $message, $accessToken = null, $branch = null, $committerName = null, $committerEmail = null, $authorName = null, $authorEmail = null)
    {
        $returnType = '\Gitee\Model\CommitContent';
        $request = $this->putV5ReposOwnerRepoContentsPathRequest($owner, $repo, $path, $content, $sha, $message, $accessToken, $branch, $committerName, $committerEmail, $authorName, $authorEmail);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\CommitContent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putV5ReposOwnerRepoContentsPathAsync
     *
     * 更新文件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径 (required)
     * @param  string $content 文件内容, 要用 base64 编码 (required)
     * @param  string $sha 文件的 Blob SHA，可通过 [获取仓库具体路径下的内容] API 获取 (required)
     * @param  string $message 提交信息 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $branch 分支名称。默认为仓库对默认分支 (optional)
     * @param  string $committerName Committer的名字，默认为当前用户的名字 (optional)
     * @param  string $committerEmail Committer的邮箱，默认为当前用户的邮箱 (optional)
     * @param  string $authorName Author的名字，默认为当前用户的名字 (optional)
     * @param  string $authorEmail Author的邮箱，默认为当前用户的邮箱 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putV5ReposOwnerRepoContentsPathAsync($owner, $repo, $path, $content, $sha, $message, $accessToken = null, $branch = null, $committerName = null, $committerEmail = null, $authorName = null, $authorEmail = null)
    {
        return $this->putV5ReposOwnerRepoContentsPathAsyncWithHttpInfo($owner, $repo, $path, $content, $sha, $message, $accessToken, $branch, $committerName, $committerEmail, $authorName, $authorEmail)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putV5ReposOwnerRepoContentsPathAsyncWithHttpInfo
     *
     * 更新文件
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径 (required)
     * @param  string $content 文件内容, 要用 base64 编码 (required)
     * @param  string $sha 文件的 Blob SHA，可通过 [获取仓库具体路径下的内容] API 获取 (required)
     * @param  string $message 提交信息 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $branch 分支名称。默认为仓库对默认分支 (optional)
     * @param  string $committerName Committer的名字，默认为当前用户的名字 (optional)
     * @param  string $committerEmail Committer的邮箱，默认为当前用户的邮箱 (optional)
     * @param  string $authorName Author的名字，默认为当前用户的名字 (optional)
     * @param  string $authorEmail Author的邮箱，默认为当前用户的邮箱 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putV5ReposOwnerRepoContentsPathAsyncWithHttpInfo($owner, $repo, $path, $content, $sha, $message, $accessToken = null, $branch = null, $committerName = null, $committerEmail = null, $authorName = null, $authorEmail = null)
    {
        $returnType = '\Gitee\Model\CommitContent';
        $request = $this->putV5ReposOwnerRepoContentsPathRequest($owner, $repo, $path, $content, $sha, $message, $accessToken, $branch, $committerName, $committerEmail, $authorName, $authorEmail);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putV5ReposOwnerRepoContentsPath'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $path 文件的路径 (required)
     * @param  string $content 文件内容, 要用 base64 编码 (required)
     * @param  string $sha 文件的 Blob SHA，可通过 [获取仓库具体路径下的内容] API 获取 (required)
     * @param  string $message 提交信息 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $branch 分支名称。默认为仓库对默认分支 (optional)
     * @param  string $committerName Committer的名字，默认为当前用户的名字 (optional)
     * @param  string $committerEmail Committer的邮箱，默认为当前用户的邮箱 (optional)
     * @param  string $authorName Author的名字，默认为当前用户的名字 (optional)
     * @param  string $authorEmail Author的邮箱，默认为当前用户的邮箱 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putV5ReposOwnerRepoContentsPathRequest($owner, $repo, $path, $content, $sha, $message, $accessToken = null, $branch = null, $committerName = null, $committerEmail = null, $authorName = null, $authorEmail = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling putV5ReposOwnerRepoContentsPath'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling putV5ReposOwnerRepoContentsPath'
            );
        }
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling putV5ReposOwnerRepoContentsPath'
            );
        }
        // verify the required parameter 'content' is set
        if ($content === null || (is_array($content) && count($content) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content when calling putV5ReposOwnerRepoContentsPath'
            );
        }
        // verify the required parameter 'sha' is set
        if ($sha === null || (is_array($sha) && count($sha) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sha when calling putV5ReposOwnerRepoContentsPath'
            );
        }
        // verify the required parameter 'message' is set
        if ($message === null || (is_array($message) && count($message) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message when calling putV5ReposOwnerRepoContentsPath'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/contents/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                '{' . 'path' . '}',
                ObjectSerializer::toPathValue($path),
                $resourcePath
            );
        }

        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // form params
        if ($content !== null) {
            $formParams['content'] = ObjectSerializer::toFormValue($content);
        }
        // form params
        if ($sha !== null) {
            $formParams['sha'] = ObjectSerializer::toFormValue($sha);
        }
        // form params
        if ($message !== null) {
            $formParams['message'] = ObjectSerializer::toFormValue($message);
        }
        // form params
        if ($branch !== null) {
            $formParams['branch'] = ObjectSerializer::toFormValue($branch);
        }
        // form params
        if ($committerName !== null) {
            $formParams['committer[name]'] = ObjectSerializer::toFormValue($committerName);
        }
        // form params
        if ($committerEmail !== null) {
            $formParams['committer[email]'] = ObjectSerializer::toFormValue($committerEmail);
        }
        // form params
        if ($authorName !== null) {
            $formParams['author[name]'] = ObjectSerializer::toFormValue($authorName);
        }
        // form params
        if ($authorEmail !== null) {
            $formParams['author[email]'] = ObjectSerializer::toFormValue($authorEmail);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putV5ReposOwnerRepoKeysEnableId
     *
     * 启用仓库公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 公钥 ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putV5ReposOwnerRepoKeysEnableId($owner, $repo, $id, $accessToken = null)
    {
        $this->putV5ReposOwnerRepoKeysEnableIdWithHttpInfo($owner, $repo, $id, $accessToken);
    }

    /**
     * Operation putV5ReposOwnerRepoKeysEnableIdWithHttpInfo
     *
     * 启用仓库公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 公钥 ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putV5ReposOwnerRepoKeysEnableIdWithHttpInfo($owner, $repo, $id, $accessToken = null)
    {
        $returnType = '';
        $request = $this->putV5ReposOwnerRepoKeysEnableIdRequest($owner, $repo, $id, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putV5ReposOwnerRepoKeysEnableIdAsync
     *
     * 启用仓库公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 公钥 ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putV5ReposOwnerRepoKeysEnableIdAsync($owner, $repo, $id, $accessToken = null)
    {
        return $this->putV5ReposOwnerRepoKeysEnableIdAsyncWithHttpInfo($owner, $repo, $id, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putV5ReposOwnerRepoKeysEnableIdAsyncWithHttpInfo
     *
     * 启用仓库公钥
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 公钥 ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putV5ReposOwnerRepoKeysEnableIdAsyncWithHttpInfo($owner, $repo, $id, $accessToken = null)
    {
        $returnType = '';
        $request = $this->putV5ReposOwnerRepoKeysEnableIdRequest($owner, $repo, $id, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putV5ReposOwnerRepoKeysEnableId'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  int $id 公钥 ID (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putV5ReposOwnerRepoKeysEnableIdRequest($owner, $repo, $id, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling putV5ReposOwnerRepoKeysEnableId'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling putV5ReposOwnerRepoKeysEnableId'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putV5ReposOwnerRepoKeysEnableId'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/keys/enable/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putV5ReposOwnerRepoPages
     *
     * 上传设置 Pages SSL 证书和域名
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $domain 自定义域名 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $sslCertificateCrt 证书文件内容（需进行BASE64编码） (optional)
     * @param  string $sslCertificateKey 私钥文件内容（需进行BASE64编码） (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putV5ReposOwnerRepoPages($owner, $repo, $domain, $accessToken = null, $sslCertificateCrt = null, $sslCertificateKey = null)
    {
        $this->putV5ReposOwnerRepoPagesWithHttpInfo($owner, $repo, $domain, $accessToken, $sslCertificateCrt, $sslCertificateKey);
    }

    /**
     * Operation putV5ReposOwnerRepoPagesWithHttpInfo
     *
     * 上传设置 Pages SSL 证书和域名
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $domain 自定义域名 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $sslCertificateCrt 证书文件内容（需进行BASE64编码） (optional)
     * @param  string $sslCertificateKey 私钥文件内容（需进行BASE64编码） (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putV5ReposOwnerRepoPagesWithHttpInfo($owner, $repo, $domain, $accessToken = null, $sslCertificateCrt = null, $sslCertificateKey = null)
    {
        $returnType = '';
        $request = $this->putV5ReposOwnerRepoPagesRequest($owner, $repo, $domain, $accessToken, $sslCertificateCrt, $sslCertificateKey);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putV5ReposOwnerRepoPagesAsync
     *
     * 上传设置 Pages SSL 证书和域名
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $domain 自定义域名 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $sslCertificateCrt 证书文件内容（需进行BASE64编码） (optional)
     * @param  string $sslCertificateKey 私钥文件内容（需进行BASE64编码） (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putV5ReposOwnerRepoPagesAsync($owner, $repo, $domain, $accessToken = null, $sslCertificateCrt = null, $sslCertificateKey = null)
    {
        return $this->putV5ReposOwnerRepoPagesAsyncWithHttpInfo($owner, $repo, $domain, $accessToken, $sslCertificateCrt, $sslCertificateKey)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putV5ReposOwnerRepoPagesAsyncWithHttpInfo
     *
     * 上传设置 Pages SSL 证书和域名
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $domain 自定义域名 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $sslCertificateCrt 证书文件内容（需进行BASE64编码） (optional)
     * @param  string $sslCertificateKey 私钥文件内容（需进行BASE64编码） (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putV5ReposOwnerRepoPagesAsyncWithHttpInfo($owner, $repo, $domain, $accessToken = null, $sslCertificateCrt = null, $sslCertificateKey = null)
    {
        $returnType = '';
        $request = $this->putV5ReposOwnerRepoPagesRequest($owner, $repo, $domain, $accessToken, $sslCertificateCrt, $sslCertificateKey);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putV5ReposOwnerRepoPages'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $domain 自定义域名 (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  string $sslCertificateCrt 证书文件内容（需进行BASE64编码） (optional)
     * @param  string $sslCertificateKey 私钥文件内容（需进行BASE64编码） (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putV5ReposOwnerRepoPagesRequest($owner, $repo, $domain, $accessToken = null, $sslCertificateCrt = null, $sslCertificateKey = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling putV5ReposOwnerRepoPages'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling putV5ReposOwnerRepoPages'
            );
        }
        // verify the required parameter 'domain' is set
        if ($domain === null || (is_array($domain) && count($domain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain when calling putV5ReposOwnerRepoPages'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/pages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // form params
        if ($domain !== null) {
            $formParams['domain'] = ObjectSerializer::toFormValue($domain);
        }
        // form params
        if ($sslCertificateCrt !== null) {
            $formParams['ssl_certificate_crt'] = ObjectSerializer::toFormValue($sslCertificateCrt);
        }
        // form params
        if ($sslCertificateKey !== null) {
            $formParams['ssl_certificate_key'] = ObjectSerializer::toFormValue($sslCertificateKey);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putV5ReposOwnerRepoPushConfig
     *
     * 修改仓库推送规则设置
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  bool $restrictPushOwnCommit 启用只能推送自己的提交（所推送提交中的邮箱必须与推送者所设置的提交邮箱一致） (optional)
     * @param  bool $restrictAuthorEmailSuffix 启用只允许指定邮箱域名后缀的提交 (optional)
     * @param  string $authorEmailSuffix 指定邮箱域名的后缀 (optional)
     * @param  bool $restrictCommitMessage 启用提交信息正则表达式校验 (optional)
     * @param  string $commitMessageRegex 用于验证提交信息的正则表达式 (optional)
     * @param  bool $restrictFileSize 启用限制单文件大小 (optional)
     * @param  int $maxFileSize 限制单文件大小（MB） (optional)
     * @param  bool $exceptManager 仓库管理员不受上述规则限制 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\ProjectPushConfig
     */
    public function putV5ReposOwnerRepoPushConfig($owner, $repo, $accessToken = null, $restrictPushOwnCommit = null, $restrictAuthorEmailSuffix = null, $authorEmailSuffix = null, $restrictCommitMessage = null, $commitMessageRegex = null, $restrictFileSize = null, $maxFileSize = null, $exceptManager = null)
    {
        list($response) = $this->putV5ReposOwnerRepoPushConfigWithHttpInfo($owner, $repo, $accessToken, $restrictPushOwnCommit, $restrictAuthorEmailSuffix, $authorEmailSuffix, $restrictCommitMessage, $commitMessageRegex, $restrictFileSize, $maxFileSize, $exceptManager);
        return $response;
    }

    /**
     * Operation putV5ReposOwnerRepoPushConfigWithHttpInfo
     *
     * 修改仓库推送规则设置
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  bool $restrictPushOwnCommit 启用只能推送自己的提交（所推送提交中的邮箱必须与推送者所设置的提交邮箱一致） (optional)
     * @param  bool $restrictAuthorEmailSuffix 启用只允许指定邮箱域名后缀的提交 (optional)
     * @param  string $authorEmailSuffix 指定邮箱域名的后缀 (optional)
     * @param  bool $restrictCommitMessage 启用提交信息正则表达式校验 (optional)
     * @param  string $commitMessageRegex 用于验证提交信息的正则表达式 (optional)
     * @param  bool $restrictFileSize 启用限制单文件大小 (optional)
     * @param  int $maxFileSize 限制单文件大小（MB） (optional)
     * @param  bool $exceptManager 仓库管理员不受上述规则限制 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\ProjectPushConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function putV5ReposOwnerRepoPushConfigWithHttpInfo($owner, $repo, $accessToken = null, $restrictPushOwnCommit = null, $restrictAuthorEmailSuffix = null, $authorEmailSuffix = null, $restrictCommitMessage = null, $commitMessageRegex = null, $restrictFileSize = null, $maxFileSize = null, $exceptManager = null)
    {
        $returnType = '\Gitee\Model\ProjectPushConfig';
        $request = $this->putV5ReposOwnerRepoPushConfigRequest($owner, $repo, $accessToken, $restrictPushOwnCommit, $restrictAuthorEmailSuffix, $authorEmailSuffix, $restrictCommitMessage, $commitMessageRegex, $restrictFileSize, $maxFileSize, $exceptManager);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\ProjectPushConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putV5ReposOwnerRepoPushConfigAsync
     *
     * 修改仓库推送规则设置
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  bool $restrictPushOwnCommit 启用只能推送自己的提交（所推送提交中的邮箱必须与推送者所设置的提交邮箱一致） (optional)
     * @param  bool $restrictAuthorEmailSuffix 启用只允许指定邮箱域名后缀的提交 (optional)
     * @param  string $authorEmailSuffix 指定邮箱域名的后缀 (optional)
     * @param  bool $restrictCommitMessage 启用提交信息正则表达式校验 (optional)
     * @param  string $commitMessageRegex 用于验证提交信息的正则表达式 (optional)
     * @param  bool $restrictFileSize 启用限制单文件大小 (optional)
     * @param  int $maxFileSize 限制单文件大小（MB） (optional)
     * @param  bool $exceptManager 仓库管理员不受上述规则限制 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putV5ReposOwnerRepoPushConfigAsync($owner, $repo, $accessToken = null, $restrictPushOwnCommit = null, $restrictAuthorEmailSuffix = null, $authorEmailSuffix = null, $restrictCommitMessage = null, $commitMessageRegex = null, $restrictFileSize = null, $maxFileSize = null, $exceptManager = null)
    {
        return $this->putV5ReposOwnerRepoPushConfigAsyncWithHttpInfo($owner, $repo, $accessToken, $restrictPushOwnCommit, $restrictAuthorEmailSuffix, $authorEmailSuffix, $restrictCommitMessage, $commitMessageRegex, $restrictFileSize, $maxFileSize, $exceptManager)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putV5ReposOwnerRepoPushConfigAsyncWithHttpInfo
     *
     * 修改仓库推送规则设置
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  bool $restrictPushOwnCommit 启用只能推送自己的提交（所推送提交中的邮箱必须与推送者所设置的提交邮箱一致） (optional)
     * @param  bool $restrictAuthorEmailSuffix 启用只允许指定邮箱域名后缀的提交 (optional)
     * @param  string $authorEmailSuffix 指定邮箱域名的后缀 (optional)
     * @param  bool $restrictCommitMessage 启用提交信息正则表达式校验 (optional)
     * @param  string $commitMessageRegex 用于验证提交信息的正则表达式 (optional)
     * @param  bool $restrictFileSize 启用限制单文件大小 (optional)
     * @param  int $maxFileSize 限制单文件大小（MB） (optional)
     * @param  bool $exceptManager 仓库管理员不受上述规则限制 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putV5ReposOwnerRepoPushConfigAsyncWithHttpInfo($owner, $repo, $accessToken = null, $restrictPushOwnCommit = null, $restrictAuthorEmailSuffix = null, $authorEmailSuffix = null, $restrictCommitMessage = null, $commitMessageRegex = null, $restrictFileSize = null, $maxFileSize = null, $exceptManager = null)
    {
        $returnType = '\Gitee\Model\ProjectPushConfig';
        $request = $this->putV5ReposOwnerRepoPushConfigRequest($owner, $repo, $accessToken, $restrictPushOwnCommit, $restrictAuthorEmailSuffix, $authorEmailSuffix, $restrictCommitMessage, $commitMessageRegex, $restrictFileSize, $maxFileSize, $exceptManager);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putV5ReposOwnerRepoPushConfig'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $accessToken 用户授权码 (optional)
     * @param  bool $restrictPushOwnCommit 启用只能推送自己的提交（所推送提交中的邮箱必须与推送者所设置的提交邮箱一致） (optional)
     * @param  bool $restrictAuthorEmailSuffix 启用只允许指定邮箱域名后缀的提交 (optional)
     * @param  string $authorEmailSuffix 指定邮箱域名的后缀 (optional)
     * @param  bool $restrictCommitMessage 启用提交信息正则表达式校验 (optional)
     * @param  string $commitMessageRegex 用于验证提交信息的正则表达式 (optional)
     * @param  bool $restrictFileSize 启用限制单文件大小 (optional)
     * @param  int $maxFileSize 限制单文件大小（MB） (optional)
     * @param  bool $exceptManager 仓库管理员不受上述规则限制 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putV5ReposOwnerRepoPushConfigRequest($owner, $repo, $accessToken = null, $restrictPushOwnCommit = null, $restrictAuthorEmailSuffix = null, $authorEmailSuffix = null, $restrictCommitMessage = null, $commitMessageRegex = null, $restrictFileSize = null, $maxFileSize = null, $exceptManager = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling putV5ReposOwnerRepoPushConfig'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling putV5ReposOwnerRepoPushConfig'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/push_config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // form params
        if ($restrictPushOwnCommit !== null) {
            $formParams['restrict_push_own_commit'] = ObjectSerializer::toFormValue($restrictPushOwnCommit);
        }
        // form params
        if ($restrictAuthorEmailSuffix !== null) {
            $formParams['restrict_author_email_suffix'] = ObjectSerializer::toFormValue($restrictAuthorEmailSuffix);
        }
        // form params
        if ($authorEmailSuffix !== null) {
            $formParams['author_email_suffix'] = ObjectSerializer::toFormValue($authorEmailSuffix);
        }
        // form params
        if ($restrictCommitMessage !== null) {
            $formParams['restrict_commit_message'] = ObjectSerializer::toFormValue($restrictCommitMessage);
        }
        // form params
        if ($commitMessageRegex !== null) {
            $formParams['commit_message_regex'] = ObjectSerializer::toFormValue($commitMessageRegex);
        }
        // form params
        if ($restrictFileSize !== null) {
            $formParams['restrict_file_size'] = ObjectSerializer::toFormValue($restrictFileSize);
        }
        // form params
        if ($maxFileSize !== null) {
            $formParams['max_file_size'] = ObjectSerializer::toFormValue($maxFileSize);
        }
        // form params
        if ($exceptManager !== null) {
            $formParams['except_manager'] = ObjectSerializer::toFormValue($exceptManager);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putV5ReposOwnerRepoReviewer
     *
     * 修改代码审查设置
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $assignees 审查人员username，可多个，半角逗号分隔，如：(username1,username2) (required)
     * @param  string $testers 测试人员username，可多个，半角逗号分隔，如：(username1,username2) (required)
     * @param  int $assigneesNumber 最少审查人数 (required)
     * @param  int $testersNumber 最少测试人数 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Gitee\Model\Project
     */
    public function putV5ReposOwnerRepoReviewer($owner, $repo, $assignees, $testers, $assigneesNumber, $testersNumber, $accessToken = null)
    {
        list($response) = $this->putV5ReposOwnerRepoReviewerWithHttpInfo($owner, $repo, $assignees, $testers, $assigneesNumber, $testersNumber, $accessToken);
        return $response;
    }

    /**
     * Operation putV5ReposOwnerRepoReviewerWithHttpInfo
     *
     * 修改代码审查设置
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $assignees 审查人员username，可多个，半角逗号分隔，如：(username1,username2) (required)
     * @param  string $testers 测试人员username，可多个，半角逗号分隔，如：(username1,username2) (required)
     * @param  int $assigneesNumber 最少审查人数 (required)
     * @param  int $testersNumber 最少测试人数 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \Gitee\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Gitee\Model\Project, HTTP status code, HTTP response headers (array of strings)
     */
    public function putV5ReposOwnerRepoReviewerWithHttpInfo($owner, $repo, $assignees, $testers, $assigneesNumber, $testersNumber, $accessToken = null)
    {
        $returnType = '\Gitee\Model\Project';
        $request = $this->putV5ReposOwnerRepoReviewerRequest($owner, $repo, $assignees, $testers, $assigneesNumber, $testersNumber, $accessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Gitee\Model\Project',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putV5ReposOwnerRepoReviewerAsync
     *
     * 修改代码审查设置
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $assignees 审查人员username，可多个，半角逗号分隔，如：(username1,username2) (required)
     * @param  string $testers 测试人员username，可多个，半角逗号分隔，如：(username1,username2) (required)
     * @param  int $assigneesNumber 最少审查人数 (required)
     * @param  int $testersNumber 最少测试人数 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putV5ReposOwnerRepoReviewerAsync($owner, $repo, $assignees, $testers, $assigneesNumber, $testersNumber, $accessToken = null)
    {
        return $this->putV5ReposOwnerRepoReviewerAsyncWithHttpInfo($owner, $repo, $assignees, $testers, $assigneesNumber, $testersNumber, $accessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putV5ReposOwnerRepoReviewerAsyncWithHttpInfo
     *
     * 修改代码审查设置
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $assignees 审查人员username，可多个，半角逗号分隔，如：(username1,username2) (required)
     * @param  string $testers 测试人员username，可多个，半角逗号分隔，如：(username1,username2) (required)
     * @param  int $assigneesNumber 最少审查人数 (required)
     * @param  int $testersNumber 最少测试人数 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putV5ReposOwnerRepoReviewerAsyncWithHttpInfo($owner, $repo, $assignees, $testers, $assigneesNumber, $testersNumber, $accessToken = null)
    {
        $returnType = '\Gitee\Model\Project';
        $request = $this->putV5ReposOwnerRepoReviewerRequest($owner, $repo, $assignees, $testers, $assigneesNumber, $testersNumber, $accessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putV5ReposOwnerRepoReviewer'
     *
     * @param  string $owner 仓库所属空间地址(企业、组织或个人的地址path) (required)
     * @param  string $repo 仓库路径(path) (required)
     * @param  string $assignees 审查人员username，可多个，半角逗号分隔，如：(username1,username2) (required)
     * @param  string $testers 测试人员username，可多个，半角逗号分隔，如：(username1,username2) (required)
     * @param  int $assigneesNumber 最少审查人数 (required)
     * @param  int $testersNumber 最少测试人数 (required)
     * @param  string $accessToken 用户授权码 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putV5ReposOwnerRepoReviewerRequest($owner, $repo, $assignees, $testers, $assigneesNumber, $testersNumber, $accessToken = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling putV5ReposOwnerRepoReviewer'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling putV5ReposOwnerRepoReviewer'
            );
        }
        // verify the required parameter 'assignees' is set
        if ($assignees === null || (is_array($assignees) && count($assignees) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $assignees when calling putV5ReposOwnerRepoReviewer'
            );
        }
        // verify the required parameter 'testers' is set
        if ($testers === null || (is_array($testers) && count($testers) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $testers when calling putV5ReposOwnerRepoReviewer'
            );
        }
        // verify the required parameter 'assigneesNumber' is set
        if ($assigneesNumber === null || (is_array($assigneesNumber) && count($assigneesNumber) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $assigneesNumber when calling putV5ReposOwnerRepoReviewer'
            );
        }
        // verify the required parameter 'testersNumber' is set
        if ($testersNumber === null || (is_array($testersNumber) && count($testersNumber) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $testersNumber when calling putV5ReposOwnerRepoReviewer'
            );
        }

        $resourcePath = '/v5/repos/{owner}/{repo}/reviewer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }

        // form params
        if ($accessToken !== null) {
            $formParams['access_token'] = ObjectSerializer::toFormValue($accessToken);
        }
        // form params
        if ($assignees !== null) {
            $formParams['assignees'] = ObjectSerializer::toFormValue($assignees);
        }
        // form params
        if ($testers !== null) {
            $formParams['testers'] = ObjectSerializer::toFormValue($testers);
        }
        // form params
        if ($assigneesNumber !== null) {
            $formParams['assignees_number'] = ObjectSerializer::toFormValue($assigneesNumber);
        }
        // form params
        if ($testersNumber !== null) {
            $formParams['testers_number'] = ObjectSerializer::toFormValue($testersNumber);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
